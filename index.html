<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="关于夏天的一切">
<meta property="og:url" content="https://zsummer.github.io/index.html">
<meta property="og:site_name" content="关于夏天的一切">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="夏天">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zsummer.github.io/"/>





  <title>关于夏天的一切</title>
  














<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">关于夏天的一切</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我总觉得对你的爱很美</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/06/16/2020-06-16-lua-oop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/2020-06-16-lua-oop/" itemprop="url">游戏中的脚本设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-16T00:00:00+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2><span id="脚本设计">脚本设计</span></h2><h3><span id="前言">前言</span></h3><p>每种语言都有自己的惯用思维, 面对领域需求时, 也应该在不同的语言思维环境下寻找解决方案, 而不是生搬硬套另外一种语言的特性, 但是从可计算性的角度上来看, 相同需求的良好解决方案往往具备很强的相似性.  </p>
<p>那么更具体的领域中, 我们说说技能系统的场景:  </p>
<p>技能系统的复杂度偏向问题域, 如果不去约束问题域的规模, 最好的解决方案一定是通过脚本化方式让技能的设计者直接去写设计者期望的战斗逻辑. 但是作为一门通用的语言, 是需要转化为一个简洁的, 低门槛的领域语言.  </p>
<p>这里不讨论如何拆解该系统所面对的问题域, 如何抽象出解决域的模型等, 这部分在之前的技能系统相关的PPT中已经描述过,  这里主要关注的是, 在使用脚本的情况下, 我们如何对脚本这部分进行更具体的设计.   </p>
<ul>
<li>作为开发者, 更关注的是开发测试成本, 即用最简洁的代码, 一劳永逸的提供最丰富的上层接口.   </li>
<li>作为设计者, 更关注的是是否提供了足够的封装, 隐藏掉不需要关心的功能实现细节以及流程细节, 并且能够总是通过简单的if else call来完成所有决策, 或者用简单的枚举或者画图 打钩完成所有决策而不需要操刀脚本编写.  <ul>
<li>更进一步的, 从设计者角度, 按照配置的出场频度和复杂度应该有如下的方案排序:<font color="#f33" size="3">   <ul>
<li>几乎总是需要配置的:  默认配置方案,  什么都不需要做就是应该有的功能或者流程   </li>
<li>次高频:  通过开关来切换功能或者流程   </li>
<li>高频: 通过枚举来完成多功能或者多流程case   </li>
<li>高频略复杂: 通过枚举+固定的跟随参数来完成   </li>
<li>高频略复杂: 开发人员编写特定的功能模块, 条件模块, 并提炼出参数以特定枚举方式提供   </li>
<li>中低频复杂条件: 嵌入简短的脚本, 通过数据接口+脚本提供的布尔表达式来完成   </li>
<li>中低频复杂逻辑: 开发人员使用脚本封装好逻辑, 提供脚本接口供设计者配置 </li></ul></font>      </li>
</ul>
</li>
</ul>


<p>对于一些硬核的项目, 例如设计者本身就有一定的CS基础或者对脚本比较熟悉,  那么其实作为开发者只要提供基础功能和接口, 就可以完全用脚本来铺展所有的工作了  </p>
<p>但是不同的项目有不同的思维风格, 考虑进一步压缩编写脚本的情景, 或者说我们希望把要手动写脚本才能解决问题的范围从例如40%压缩到5% …<br>除了<strong>数据驱动相关的组合拳, 以堆开发量减少这个范围外</strong>, 还考虑了另外一个路径来减少开发成本和代码风险.<br><font color="#f33" size="3"></font></p>
<ul>
<li>在配置接口和脚本接口之间添加一个中间层脚本, 使用脚本语言自身的封装特性进一步简化接口, 并且支持热更.      <ul>
<li>在中间层编写复杂逻辑的封装, 保证C++内核的代码稳定性和质量稳定性   </li>
</ul>
</li>
<li>在配置层增加模版机制或者脚本片段选择机制, 提供更简洁高效的脚本配置途径.  </li>
<li>在部分中低频数据驱动的配置方案中, 采用翻译为脚本的快速形式, 减少代码风险提供开发速度   



</li>
</ul>
<h3><span id="how-to">how to</span></h3><p>如何实现这样一套完善的脚本体系呢 ?   </p>
<ul>
<li><p>提炼技能系统的meta数据   </p>
<blockquote>
<p>这里的meta数据, 意思是把一个能表征技能状态和数据的关键元素提取出来单独维护, 它足够小但足够提供我们关心的所有信息.  例如初始状态, 当前状态, 可追溯的来源信息, 相关联的配置ID, 上下文等.<br>这份meta数据会成为脚本的基础数据环境, 通过这个meta信息我们可以查询相关的配置 状态, 以作为某些条件的判定依据, 以及新的行为的参数.<br>必要时我们可以拷贝这份meta数据, 或者伪造修饰部分数据来提供更特殊的环境实现.    </p>
</blockquote>
</li>
<li><p>基础的脚本胶水接口实现 (开发向低级接口)   </p>
<blockquote>
<p>一次性提供所有meta数据的访问接口<br>提供C侧基于meta数据的功能函数封装, 尽可能的做到原子性   </p>
</blockquote>
</li>
<li><p>编写模板类, 提供易用 易读 易使用的高级接口  </p>
<blockquote>
<p>一次性翻译低级接口到高级接口,  这个过程会隐藏掉例如meta数据本身访问等<br>编写高级封装    </p>
</blockquote>
</li>
<li><p>在C++代码中打桩  </p>
<blockquote>
<p>把来自设计者的脚本片段和合成一个临时函数并压栈<br>把meta数据和调用信息压栈, 作为临时函数的参数去执行.<br>这里为了简化不同流程的桩点环境和不同事件的桩点环境不同, 并不会编写不同的桩点代码而是统一使用meta数据,  这样再脚本系统的实现上就做到了统一的埋点处理, 极大的减少了因此带来的桩点代码量.<br>桩点中来自策划的脚本片段实际执行会经过’模板类’这个中间层,  而这个中间层存储在可热更的单独文件中.<br>打桩的脚本代码在首次执行时会处理为字节码提高性能, 热更配置会清除字节码.<br>模板类脚本也为字节码 可热更.   </p>
</blockquote>
</li>
<li><p>注意项:  对脚本调用可能存在嵌套, 例如在脚本事件中触发新的脚本甚至重入  </p>
<blockquote>
<p>在每段可能会触发脚本的关键路径上进行stack计数, 超过计数block掉该流程.<br>脚本环境支持嵌套, 或者说脚本环境(包含技能meta和脚本环境实例)应该是放在栈上. </p>
</blockquote>
</li>
</ul>
<h3><span id="detail">detail</span></h3><h4><span id="lua的oop模拟">lua的OOP模拟</span></h4><p>需要解释下是 lua没有类的概念, 只有实例(table).  但是lua的table是可以聚合函数和数据的, 并且存在metatable这种元表概念, 因此在在lua的语法特性中我们可以用以下方式来完成一个接近OOP的模拟, 基本思路如下:  </p>
<ul>
<li><p>构造一个全局的table实例作为创建实例的metatable(类的概念)   </p>
</li>
<li><p>提供一个公共的new接口来创建一个新表, 并设置好metatable的关系. (实例化)  </p>
</li>
<li><p>以:形式来编写所有函数完成C++this指针的作用, 即所有函数的实现默认第一个参数为实例自身, 调用时默认用自身作为函数的第一个参数   </p>
</li>
<li><p>其简洁的实现形式如下:   </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义全局table  </span></span><br><span class="line">meta = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--数据成员 </span></span><br><span class="line">meta.class_name = <span class="string">"meta"</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">--函数成员</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">meta:desc</span><span class="params">(msg)</span></span></span><br><span class="line">    <span class="built_in">print</span>(self.class_name .. <span class="string">": "</span> .. msg)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--这个:是一个语法糖, 等价代码:</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">function meta.desc(self, msg)</span></span><br><span class="line"><span class="comment">    print(self.class_name .. ": " .. msg)</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--实例化方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">meta.New</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> inst = &#123;...&#125;  </span><br><span class="line">    <span class="built_in">setmetatable</span>(inst, &#123; <span class="built_in">__index</span> = meta &#125;)   <span class="comment">--设置metatable 当inst中不存在某个键，会读出meta相应的元方法   </span></span><br><span class="line">    <span class="keyword">return</span> inst</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--实例化一个meta的实例  </span></span><br><span class="line"><span class="keyword">local</span> inst = meta.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改新实例的class_name为inst    </span></span><br><span class="line">inst.class_name = <span class="string">"inst"</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">--子类并没有desc方法 会尝试读meta的desc 并把inst实例以self参数传入该方法    </span></span><br><span class="line">inst:desc(<span class="string">"new inst"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>output  <blockquote>
<p> inst: new inst</p>
</blockquote>
</li>
</ul>
<h4><span id="实际应用">实际应用</span></h4><ul>
<li>统一的桩点代码<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(skill_meta, result, ...)</span></span></span><br><span class="line">  <span class="keyword">local</span> inst_env = &#123;skill_meta, result, ...&#125;</span><br><span class="line">  <span class="built_in">setmetatable</span>(inst_env, &#123; <span class="built_in">__index</span> = meta_env &#125;)</span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">     <span class="comment">--配置开始</span></span><br><span class="line">     <span class="comment">--inst_env:cast_skill(...)</span></span><br><span class="line">     <span class="comment">--配置结束</span></span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<ul>
<li></li>
<li><p>…</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/05/09/2020-06-15-shadowsock-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/2020-06-15-shadowsock-proxy/" itemprop="url">shadowsocks代理远端和本地配置以及VPS上的bbr开启等</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="shadowsocks服务器配置"><a href="#shadowsocks服务器配置" class="headerlink" title="shadowsocks服务器配置"></a>shadowsocks服务器配置</h2><ul>
<li><p>安装shadowsocks  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shadowsocks</span><br></pre></td></tr></table></figure></li>
<li><p>配置shadowsocks<br>配置路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;shadowsocks&#x2F;config.json</span><br></pre></td></tr></table></figure></li>
<li><p>配置内容(参考):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:[&quot;::1&quot;, &quot;0.0.0.0&quot;],</span><br><span class="line">  &quot;mode&quot;:&quot;tcp_and_udp&quot;,</span><br><span class="line">  &quot;server_port&quot;:8080,</span><br><span class="line">  &quot;password&quot;:&quot;****&quot;,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/05/09/2020-06-15-shadowsock-proxy/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/05/09/2020-05-09-memory_alloctor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/2020-05-09-memory_alloctor/" itemprop="url">内存分配器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2><span id="内存分配器核心思想和算法">内存分配器核心思想和算法</span></h2><h3><span id="内存管理策略">内存管理策略</span></h3><h4><span id="sequential-fit-连续适配">Sequential Fit  (连续适配)</span></h4><p> 是基于一个单向或双向链表管理各个blocks的基础算法，因为和blocks的个数有关，性能比较差。这一类算法包括Fast-Fit, First-Fit, Next-Fit, and Worst-Fit。  </p>
<h4><span id="segregated-list-分离列表">Segregated List (分离列表)</span></h4><p> 将所有的空闲块，放入到一组链表中，每一个链表中只包含某一个大小范围的空闲块  </p>
<ul>
<li>Buddy System (Sequential Fit变种)  <ul>
<li>内部碎片化问题比较严重   </li>
<li>Binary Buddies  </li>
<li>Fibonacci Buddies  </li>
<li>Weighted Buddies   </li>
</ul>
</li>
</ul>
<h4><span id="indexed-fit">Indexed  Fit</span></h4><p> 通过一些高阶的数据结构来索引（Index）空闲的内存块。例如基于平衡树的“Best Fit”算法。</p>
<ul>
<li>使用Balanced Tree的Best Fit allocator</li>
<li>使用Cartesian tree 的Stephenson Fast-Fit allocator</li>
<li>Bitmap Fit (Indexed Fit 变种)<br>Indexed Fit算法的变种，通过一小段内存的位图来标记对应的内存是空闲的还是使用中。  </li>
</ul>
<h3><span id="路径匹配策略">路径匹配策略</span></h3><p>对于操作系统而言, 除了管理进程之外, 还需要有效的管理计算机的主内存, 管理主内存的共享使用和最小化内存访问时间是内存管理器的基本目标. 虽然使用了各种不同的策略来为争夺内存的进程分配空间，但最流行的三种策略是最佳匹配、最不适合匹配和首次匹配.    </p>
<ul>
<li>Best fit:<br>The allocator places a process in the smallest block of unallocated memory in which it will fit. For example, suppose a process requests 12KB of memory and the memory manager currently has a list of unallocated blocks of 6KB, 14KB, 19KB, 11KB, and 13KB blocks. The best-fit strategy will allocate 12KB of the 13KB block to the process.<br>最佳匹配:<br>这种匹配策略中, 分配器会从满足匹配要求的未分配内存中选择最小的块.<br>例如程序请求一个12kb的内存, 而当前的内存管理器有一个未分配的内存块列表, 分别为14k, 19k, 11k, 13k, 那么best-fit讲从13k的内存块中分配内存给程序.  </li>
</ul>
<ul>
<li><p>Worst fit:<br>The memory manager places a process in the largest block of unallocated memory available. The idea is that this placement will create the largest hold after the allocations, thus increasing the possibility that, compared to best fit, another process can use the remaining space. Using the same example as above, worst fit will allocate 12KB of the 19KB block to the process, leaving a 7KB block for future use.<br>最不适合匹配<br>内存管理器总是选择获得的最大的那个未分配内存块.<br>这种策略在每次分配后总是持有最大的内存块, 从而增加匹配的可能性. 与最佳匹配相比, 其他的请求可以使用剩余的空间.(最佳匹配的剩余内存往往无法利用)<br>同上例, 最坏匹配会从19k的那个内存块中分配, 并留下7k的内存留给将来使用.  </p>
</li>
<li><p>First fit:<br>There may be many holes in the memory, so the operating system, to reduce the amount of time it spends analyzing the available spaces, begins at the start of primary memory and allocates memory from the first hole it encounters large enough to satisfy the request. Using the same example as above, first fit will allocate 12KB of the 14KB block to the process.<br>通常内存中会存在很多空洞, 所以操作系统为了减少分析可用空间的性能(时间)消耗, 会从主要内存或者 第一个足够大并且满足求要的可分配内存的起始位置相应请求.<br>同上例中, 首先匹配会从14k的block中分配12k的请求.<br>First Fit的一个改良版本叫做Next Fit, 即在下次请求时会从上次中断的地方的开始搜索, 从而避免总是从起始的空闲内存开始查找. (Designated victim), First Fit的策略会倾向于总是把大块切的更零碎也因此带来更多的外部碎片问题, 也因为总是从空闲内存的头部开始切造成更多的内部碎片,  而Next Fit的做法会避免(改良)这些问题, 并且速度比Firt 以及 Best更快.  </p>
</li>
</ul>
<h4><span id="tlsf-a-new-dynamic-memory-allocator-for-real-time-systems">TLSF: a New Dynamic Memory Allocator for Real-Time Systems</span></h4><p>通过一组链表来管理不同大小内存块的内存分配算法。<br>适用环境和要求:<br>内存分配/释放的执行时间可预期，可接受的。由于RTOS对指令的执行时间有严格要求，所以常常采用静态内存分配的方法，以获得一个可以预期的执行时间。<br>内存分配算法的碎片化程度要低，这是由于RTOS往往长时间执行，碎片化程度高会导致内存分配失败。<br>实时系统动态内存算法<br>可信的执行环境，Trusted Environment，应用不会故意破坏数据或者窃取数据。<br>有限的物理内存。<br>没有物理MMU来支持虚拟内存。</p>
<p>核心概念: Two Level<br>基本的Segregated Fit算法是使用一组链表，每个链表只包含特定长度范围来的空闲块的方式来管理空闲块的，这样链表数组的长度可能会很大。如下图，TLSF为了简化查找定位过程，使用了两层链表。第一层，将空闲内存块的大小根据2的幂进行分类，如（16、32、64…）。第二层链表在第一层的基础上，按照一定的间隔，线性分段。比如2的6次方这一段，分为4个小区间【64,80），【80,96），【96,112），【112，128）.每一级的链表都有一个bitmap用于标记对应的链表中是否有内存块。比如第一级别bitmap的后4bit位0100，即2的6次方这个区间有空闲块。对应的第二级链表的bitmap位0010及【80,96）这个区间有空闲块，即下面的89 Byte。</p>
<p>策略:<br>Immediate coalescing，立即合并，当内存块被释放后，立即与相邻的空闲内存块合并，以获得一个更大的空闲块，插入到链表的相应位置。这样可以减少碎片化。<br>Splitting threshold，分割阈值，最小可分配的内存块大小为16字节，应用一般不会分配一些基本的数据结构，如int、char等。限定最小可分配大小为16字节，这样可以在空闲的内存块中存储一些管理信息。<br>Good-fit strategy，TLSF会尽可能的返回一个最小的、能够满足需求的内存块。<br>Same strategy for all block sizes，对于不同大小的内存请求，TLSF只有一个分配策略，实现相对简单，执行时间可以预期。相应的dlmalloc根据所请求的内存大小不同，有多达4种内存分配策略。<br>Memory is not cleaned-up，分配个应用的内存没有被请0.</p>
<p>特点:<br>可以预期的分配执行时间，无论对于多达的内存分配请求，TLSF可以在限定的时间内完成分配。<br>碎片化程度低。</p>
<h4><span id="mimalloc">mimalloc:</span></h4><h4><span id="多线程">多线程</span></h4><ul>
<li>局部化, 本地缓存/链表  </li>
<li>注意false shared  </li>
<li>跨线程队列 最大本地缓存 </li>
</ul>
<h4><span id="内存安全">内存安全</span></h4><p>管理数据和被管理内存分离<br>buddy system<br>pages 管理  </p>
<p>可信的执行环境Trusted Environment，应用不会故意破坏数据或者窃取数据<br>有限的物理内存<br>有限的物理地址<br>没有物理MMU来支持虚拟内存</p>
<h4><span id="开源内存分配器">开源内存分配器</span></h4><ul>
<li>dlmalloc </li>
<li>tcmalloc  </li>
<li>jemalloc  </li>
<li>Hoard</li>
<li>minimalloc</li>
<li>TLSF: <a href="https://github.com/OlegHahm/tlsf" target="_blank" rel="noopener">https://github.com/OlegHahm/tlsf</a>    </li>
</ul>
<h4><span id="援引">援引</span></h4><p><a href="https://github.com/everschen/tools/blob/master/DOC/Jemalloc.pdf" target="_blank" rel="noopener">jemalloc深入分析 PDF</a><br><a href="http://applicative.acm.org/2015/applicative.acm.org/speaker-JasonEvans.html" target="_blank" rel="noopener">jemalloc 2015演讲视频 tick tock, malloc needs a clock 背景和初始设计思想介绍</a><br><a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919" target="_blank" rel="noopener">jemalloc facebook工程贴</a><br><a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf" target="_blank" rel="noopener">BSDcan paper 2006</a><br><a href="https://dl.acm.org/doi/abs/10.1145/3329785.3329918" target="_blank" rel="noopener">On the Impact of Memory Allocationon High-Performance Query Processing</a><br><a href="https://www.jamesgolick.com/2013/5/19/how-tcmalloc-works.html" target="_blank" rel="noopener">How tcmalloc Works</a><br><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/out-of-memory-handling" target="_blank" rel="noopener">Chromimum Project: Out of memory handling</a><br><a href="https://rd.springer.com/content/pdf/10.1007%2F978-1-4842-4398-5_7.pdf" target="_blank" rel="noopener">Scalable Memory Allocation TBB</a><br><a href="https://cloud.tencent.com/developer/article/1173720" target="_blank" rel="noopener">ptmalloc,tcmalloc和jemalloc内存分配策略研究</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/02/07/2020-02-07-shared-memory-buddy_system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/2020-02-07-shared-memory-buddy_system/" itemprop="url">基于共享内存的通用内存分配器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T00:00:00+08:00">
                2020-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3><span id="1-目录">..1. 目录</span></h3><h3><span id="linux系统的内存管理设计">linux系统的内存管理设计</span></h3><p><img src="/images/system_memory.jpg" alt="buddy_system"><br>Linux内核内存管理的一项重要工作就是如何在长期频繁申请释放内存的情况下, 避免碎片的产生.<br>Linux采用伙伴系统在极高的分配和回收性能(LGN)上, 最大化的减少了外部碎片(总是合并伙伴内存)的产生.<br>伙伴算法非常简洁并且容易实现, 其一般实现的核心思路为维护一个整块内存, 通过不断的2分把最适配的内存分配给用户, 并且总是优先选择最零碎的空闲内存进行适配, 在回收时候则总是会合并空闲的伙伴内存(左右两个子节点的关系称之为伙伴关系), 以此来尽可能的保证大块的连续内存.<br>但是伙伴算法要求分配的内存必须是2的幂次大小, 因此直接使用会带来大量的内部碎片, 也因此伙伴算法一般都是作为底层内存管理算法不直接提供给用户, 而是通过dlmalloc等slab算法或者衍生算法提供给最终用户.  </p>
<p>linux采用slab算法来进行更细粒度的内存分配管理, 通过分箱算法, 对于小内存(256字节及以下, 分离存储)可以达到常数的性能, 对于 &gt;256 &amp;&amp; &lt;1m的内存可以做到不大于LGN的分配性能, 并且通过对大块内存的精细切分和分箱算法可以做到几乎没有内部碎片, 通过对空闲内存的合并(没有伙伴关系约束也不存在假碎片问题, 但是因为大小chunk混合切分带来了更多的合并次数) 也有效的控制了外部碎片的产生.  </p>
<p>linux面对的环境在通用性上要求更高, 考虑到brk/mmap作为系统调用在一些环境下的性能差异表现, 以及小内存的在初始化数据(查找 切分等), slab相关的算法中更倾向于缓存足够多的block来保证小内存在分配上的性能表现, 而操作系统heap苛刻的收缩条件也会导致在项目中的实际表现往往是整个heap的内存总是接近保持在峰值水平上, 换句话说slab算法在实际的实现中其分配策略更接近’内存池’的概念.  </p>
<p>其分箱算法采用64位的bitmap 也就是64个箱位, 支持单个内存分配请求的大小范围在dlmalloc的实现中为8字节-1M, 又因为内存池的分配策略, 以及外部碎片的有限控制, 所以slab只是一个针对小内存分配优化方案, 对于一个通用分配器来说仍然需要大内存的分配方案.   </p>
<p>因此包括linux内核, 整体的通用内存分配方案中, 使用buddy算法或者衍生算法来做大块线性地址空间的管理, 保证性能的情况下最小化外部碎片的产生, 通过slab算法或者衍生算法维护一个小内存请求的内存池, 以增加一小部分外部碎片的代价换取更少的内部碎片产生, 并保证向buddy system索要的内存都是满足2的幂次大小,  从而得到一个综合性能最优的方案, 这个方案比喻成[buddy算法负责批发 slab算法负责零售]具有比较形象的参考价值.    </p>
<h3><span id="伙伴算法">伙伴算法</span></h3><p>因为最终的目的是希望把伙伴算法的管理结构保存在共享内存中,  因此我们在数组结构上以完美二叉树(perfect binary tree)的方式构建了整个伙伴算法,  由于对cpu cache友好的特征, 并且全局几乎只有简单的加减位移操作, 所以整个实现可以在非常简洁的基础上得到了一个比较出色的性能表现.   </p>
<h4><span id="数据结构和概述">数据结构和概述</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  perfect binary tree</span></span><br><span class="line"><span class="comment">*                   0        -----------   : reserve</span></span><br><span class="line"><span class="comment">*	                  1        -----------   :  root </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*          2                 3</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     4        5         6        7</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   8   9   10   11   12   13  14   15</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ----------------------------------------</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   0   1   2    3    4    5   6     7     : memory buff</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/buddy_system.gif" alt="buddy_system"><br>伙伴算法是一个特殊的分离适配的内存管理器  </p>
<ul>
<li><p>能被有效管理的内存大小必须是2的幂次方   </p>
</li>
<li><p>分配的内存大小一定是2的幂次大小对齐, 通过逐层向下2分找到最适配请求的大小  </p>
</li>
<li><p>回收的内存会逐层向上合并 并且总是幂次大小合并 并且只能对伙伴内存(左右子节点)进行合并     </p>
</li>
<li><p>显而易见的内部碎片<br>因为2的幂次对齐分配, 比如我们需要power(2, 12)+1 的内存 实际上就会分配power(2,13)的内存,  内部碎片比例为 (power(2, 12)+1)/power(2,13), 有效负荷只有0.5左右.<br>伙伴系统的分配粒度如果为页框机制, 例如采取页框大小为4k(方便匹配操作系统的页大小), 那么即使请求1个字节也需要一个完整的页框内存,  有效负荷只有1/(4k-1)即4k分之一.  </p>
</li>
<li><p>显而易见的假碎片<br>两块相邻的空闲内存因为不属于伙伴关系则无法合并, 换句话说存在一块连续的空闲地址满足需求但是却因为无法在内存管理器中完成合并操作而不能提供服务.<br>比如上面结构中 IDX 9 和 IDX 10皆为空闲,  IDX 9 和 IDX 5皆为空闲等      </p>
</li>
<li><p>存在但被有效控制的外部碎片<br>对于动态内存分配策略中, 只要满足通用性目标中”处理任意请求序列” 那么就一定会有外部碎片的产生, 因为其产生不仅仅在于分配器管理结构的设计, 更在于将来时, 外部的请求和释放时机.<br>  如图所示中, 我们并不能保证不会出现索引11和12被分配出去其他内存全部空闲这样的情况, 导致总空闲内存大小为6但是只能最大分配3个连续页框 .<br>但相比其他的分配方案, 合并成一个2倍大小的大块内存, 总是只需要两个空闲小块, 而在分配策略中又总是会分配大小相同且相邻的块, 可以说是所有分配策略在保证LGN性能下控制外部碎片最好的方案.  </p>
</li>
</ul>
<ul>
<li>较为恒定的分配复杂度<br>分配时会从根节点向下查找直到适配, 回收时从叶子节点向上查找, 并且都会从对应节点向根节点方向进行分配能力的修改.<br>因此一对分配和释放请求总是恒定为LGN  </li>
</ul>
<h4><span id="数据结构的定义">数据结构的定义:</span></h4><p>同linux系统的方式类似, 我们按照页框为单位来管理内存, 页框的大小大于等于系统的页框大小, 可结合slab分配器进行调整.<br>根据要管理的内存大小和页框大小, 我们可以算出总得叶子数量,  而在这棵树上, 节点总数为2N(2倍叶子节点)   </p>
<p>因此数据结构的定义为如下方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共享内存管理头部: 所有叶子节点 : 被管理的内存</span><br></pre></td></tr></table></figure>

<p>每个节点用1个字节来记录, 内容为该节点的所对应的空间大小, (这里记录的不是大小, 而是大小的幂, 所以可以用一个字节来存储)<br>该节点对应的空间起始地址这位该节点在该层中的<code>offset* power(2, order)</code></p>
<h5><span id="初始化">初始化</span></h5><p>所有节点的初始化为为该节点的空间大小.<br>例如index1 对应的则是被管理的所有空间<br>然后每层递减1<br>到叶子节点则为2^0次幂大小, 即一个页框单位.  </p>
<h5><span id="分配">分配</span></h5><p>如果分配参数是字节数, 则需要先按照页框向上取整<br>如果分配的参数是页框数量, 则需要按照2的幂次取整, 可以用bit search指令获取2的幂数(这个取法是向下取整 所以取完后要进行一次向上取整)<br>如果分配的是order<br>则检查root节点保存的order是否满足需求, 不满足这代表没有足够大的空间<br>如果满足需求则逐层查找, 直到到达对应的order层级, 然后修改该节点的可分配空间为0, 然后逐层向上修改分配能力  </p>
<p>tips:<br> 这里定义0为已分配, 而不是power(2,0)个空间大小,  因此在这里节点对应空间大小计算是power(2, (order ability)-1)   -1后才是power(2, order) .<br> 这样可以保证这棵树中从叶子节点向上查找时候的可以简单的while循环时候少一次边界判定, 计算方便   </p>
<p>分配时候永远选择刚好满足需求的路径, 可以减少切分大块, 其次优先左子树,  减少外部碎片的产生以及提高cache命中.  </p>
<h5><span id="释放">释放</span></h5><p> 通过地址计算页框编号, 然后加上N (树的大小是2N, N为所有非叶子节点的节点总数) 得到叶子节点的索引.<br> 从叶子节点用IDX /2 不断的向上查找, 直到找到节点被标记为0的层级,  修改该节点为该层级对应的空间大小, 然后逐层向上修改每层的新的空间分配能力, 如果左右节点的空间大小为该层级的大小(都空闲)则合并,(每个上层节点的能力均是节点对应的空间大小)   </p>
<h3><span id="slab内存分配器">SLAB内存分配器</span></h3><p>有了buddy system之后, 移植所有可以基于mmap或者brk批量分配的内存分配器都会变得容易, 常见的现在linux系统使用的ptmalloc属于dlmalloc的分支版本, 而常用的TCMALLOC或者jemalloc都是基于dlmalloc的思想进行了更优更细粒度的实现, 体现在cpu cache更友好的分配策略以及多线程下更少的竞争等来获取更好的分配性能.      </p>
<p>dlmalloc有着更简洁干净的实现 大约只有5000行代码, 其设计也非常的出色, 可以说是最容易移植的优秀的内存分配器.  </p>
<h4><span id="基础术语和概念如下">基础术语和概念如下:</span></h4><p>Payload: 有效负载.指的是实际交给应用程序使用的内存大小.  </p>
<p>Overhead: 负载,开销.本意是为了满足分配需求所消耗的内存量,实际在代码注释中多指除了payload之外的额外开销(有些书中也称之为cookie).  </p>
<p>Chunk: 区块.是内存分配的基本单位,类似物质世界中的原子不可再分. dlmalloc对内存的管理基本上都是以chunk为单位.一个典型的chunk是由用户程序使用的部分(payload)以及额外的标记信息(overhead)组成.  </p>
<p>Bin: 分箱.用来管理相同或同一区间大小的chunk.在dlmalloc中分为sbin和tbin两种.  </p>
<p>Mspace: 分配空间.说白了就是dlmalloc中内存池的叫法.在dlmalloc中可以管理多个mspace.如果不显式声明,将会使用一个全局的匿名空间,或者用户可以自行划分空间交给dlmalloc管理.  </p>
<p>Segment: 区段.一般情况下,内存分配都是在一片连续区间内开采(exploit).但也会遇到不连续的情况,这就需要分成若干个区段记录.多个区段可以同属一个mspace.  </p>
<p>Fenceposts: 栅栏.大多数分配器中, fencepost起到非连续内存间的隔离作用.一般这种隔离被用做安全检查.分配器会在fenceposts所在位置写上特殊标记,一旦非连续内存间发生写入溢出(overwrite)就可以通过异常的fenceposts值发出警告.  </p>
<p>Bookkeeping: 记录信息.不同于每个chunk中的overhead,这里指的是整个mspace控制块的记录信息.往往这部分信息都固定在mspace开始的一段空间,或者干脆就放在地址空间的静态区中.  </p>
<p>Granularity: 粒度.这个粒度指的是从system heap上获取内存的最小单位.一般来说该值至少为一个page size, 且必须以2为底.  </p>
<p>Mmap: 本意是类unix系统的文件映射调用.但在dlmalloc中表示的更宽泛,这里指代可以在进程地址空间中开辟非连续内存空间的系统调用.  </p>
<p>Morecore: 指可以在进程地址空间中开辟连续内存空间的系统调用.在类unix系统下morecore指的是sbrk调用.  </p>
<p>Program break: 前面提到的sbrk()实际也是一个库函数,真正起作用的是brk()系统调用.这个函数其实就是break的缩写.所谓的break是一个代表进程heap区top-most位置的指针.当我们通过sbrk/brk向系统请求内存时,系统做的仅仅是移动break指针,内存就这样被划拨到heap中了.而当释放内存时,就反方向移动该指针,内存就返回给系统.  </p>
<p>Footprint: 从系统获得的内存量.指的是当前dlmalloc从system heap获取的内存总和.设立footprint一方面是为了方便统计,另一方面也可以限制dlmalloc从系统获取的最大内存量.   </p>
<p>Trimming: 裁剪.被dlmalloc管理的内存被free后,并不直接返还给系统,而是当积累到一定程度会通过一些算法判断system heap是否收缩(shrink),这个过程在dlmalloc中称作auto-trimming.   </p>
<h4><span id="分箱机制">分箱机制</span></h4><p>分箱指的是在内存分配器内部划定一些chunk集合, 每个集合中记录的都是固定大小或区间的free chunk, 当分配时可以直接从中找到最贴近用户要求的那一个.<br>越是想要高效的分配,就越要将分箱划分的更细致,相应的也就浪费更多的内存, 因此, 分箱机制既不能太粗放而影响效率, 也不能太细致而降低利用率.<br>分箱算法通过位移的计算技巧, 可以简单且快速的找到满足请求大小的最小非空箱位索引</p>
<h4><span id="小内存分配">小内存分配</span></h4><p>dlmalloc定义了最小的分配粒度为8字节, 这样在保存chunk大小的字段中可以多出来3个位作为bit标记<br>然后每8个字节递增, 直到248字节, 总共32个箱子 如下:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[bin idx] 8 8 8 8 8 8 8 8 8 </span><br><span class="line">[bin idx] 16 16 16 16 16 16   </span><br><span class="line">[bin idx] 24 24 24 24 24 24   </span><br><span class="line">...</span><br><span class="line">[bin idx] 248 248 248 248 248 248</span><br></pre></td></tr></table></figure>

<p>在64位下需要保证分配给用户的地址是两倍(void*)大小且包含一个8字节的prev_foot 一个8字节的head, 因此实际上使用的箱位不会用满32个.<br>dlmalloc的prev_foot是一个边界标记法的使用技巧, 逻辑上其实是上一个chunk的foot部分, 如果不是空闲状态则会标记”下个chunk的P”为非空闲,  如果是空闲则会填充该字段为空闲chunk的大小.<br>这样就可以完成一个块从分配状态到空闲状态时候 总是能直接向前合并或者向后合并.<br>在非空闲状态没有合并需求, 因此为了充分利用内存, 分配状态的chunk其foot部分总是被’踩’的,  也就是说这里的的箱位使用在实际情况下(64位)<br>是32byte开始, 后面以24字节递增(踩prev_foot) 48byte 64byte 直到240byte  对于调用dlmalloc接口请求的大小在超过232字节后就会走big bin分配[256~384)范围的内存.   </p>
<p>分配:  </p>
<p>首先检查对应bin idx是否有空闲chunk 有这分配并返回<br>其次检查更高bin idx中是否有空闲的chunk, 有则切割, 并把剩余大小组合成一个新chunk记录为切割剩余chunk(如果过小则直接丢给用户)<br>其次检查大内存的bin里面是否有内存 有则切割 同上<br>其次检查上次剩余切割的chunk是否满足需要 如果满足则进一步切割 同上<br>其次检查最新从上级分配器(buddy system, 或者对应系统函数mmap brk)得到的大块chunk的剩余是否满足 满足就切割 (brk表现为扩展top)<br>其次则申请一个新的大块chunk进行切割   </p>
<h4><span id="大内存分配">大内存分配</span></h4><p>大内存的bin idx递增则为2的幂次的半高为区分 总共32个箱子, 箱内是一个特殊实现的bitwise trie tree 如:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[bin idx] [256~384)  </span><br><span class="line">[bin idx] [384~512)  </span><br><span class="line">[bin idx] [512~768)  </span><br><span class="line">[bin idx] ...  </span><br><span class="line">[bin idx] [4096~6144)  </span><br><span class="line">[bin idx] ...   </span><br><span class="line">[bin idx] [768k~1m)</span><br></pre></td></tr></table></figure>

<p>分配:<br>首先查找对应的bin idx是否存在空闲, 如果空闲则从该bitwise trie tree中查找最佳的chunk节点   </p>
<p>如果当前bin无空闲内存或者没找到合适空闲内存, 则检查更高bin idx中是否存在空闲, 如果有则拿最小的一个chunk </p>
<p>如果找到则切分保存剩余内存为剩余chunk并返回合适大小的内存给用户  </p>
<p>其次检查剩余chunk的大小是否满足, 满足则进一步切割  </p>
<p>其次检查最近一次向上层管理器申请的内存chunk是否满足需求, 满足则切分     </p>
<p>其次选择向底层(操作系统)申请满足需求的大块内存 </p>
<h5><span id="bitwise-trie-tree">bitwise trie tree</span></h5><p>大内存的箱内管理是一个特殊的前缀树, 节点均为0或者1, 和buddy system的结构稍微有点相似 都是做地址空间管理.<br>这个树的的节点是按照chunk的大小(chunk大小在二进制上的0,1顺序作为排序依据)进行构建的<br>并且其节点本身就是chunk,  因此查找时候时候不但要检测叶子节点的大小是否最佳 也要检测其节点路径的chunk大小是否是最佳.<br>添加节点时候会自顶向下查找最佳位置, 如果已经存在大小相同的节点或者叶子节点 则以链表形式附加到该节点的空闲链表中, 如果不存在则直接以叶子节点添加<br>删除(最佳)节点时, 如果该节点有相同大小的其他chunk 则直接替换为相同大小的即可, 如果是叶子节点直接摘除, 否则会从右侧叶子节点提升到该节点位置.   </p>
<p>这棵树的优点是动态树高, 查找的最坏性能是地址空间的LGN复杂度, 在树不满的情况则是相对树高的LGN复杂度,  在插入和删除时只是简单的查找+一次替换/添加操作, 不会对树进行调整, 因此性能非常好.    </p>
<h4><span id="内存回收和内存收缩">内存回收和内存收缩</span></h4><p>回收内存时会根据标志检查是否存在前一个空闲块 如果存在则合并.<br>如果是直接mmap的内存 则直接返还给底层分配器<br>检查是否满足收缩条件, 满足收缩条件则向系统/底层分配器返还内存 这里分heap的堆顶收缩检测和非连续mmap segment回收检测<br>未被返还给底层分配器则插入到对应的bin空闲块中.   </p>
<h4><span id="默认内存分配阈值">默认内存分配阈值</span></h4><p>分配对齐至少8字节 默认为两倍<code>sizeof(void*)</code><br>向系统的索要内存的最小粒度默认为64k, windows下通过api获取到的分配粒度默认也是64k (最小单位)<br>当dlmalloc的请求内存超过阈值256k时 直接向系统索要内存<br>系统的内存分配方式是brk时至少在堆顶缓存一个分配粒度的空闲内存而不是收缩堆顶所有空闲内存<br>系统的内存分配方式是mmap时会通过满足条件一定次数后扫描线性扫描所有segment列表, 对未使用并且完全空闲的segment进行清除(保留堆顶 剩余切分被占用的segment).</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/02/07/2020-02-03-shared-memory-resume-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/2020-02-03-shared-memory-resume-overview/" itemprop="url">基于共享内存的对象池管理方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T00:00:00+08:00">
                2020-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="1-目录"><a href="#1-目录" class="headerlink" title="..1. 目录"></a>..1. 目录</h3><h3 id="通用的对象池方案"><a href="#通用的对象池方案" class="headerlink" title="通用的对象池方案"></a>通用的对象池方案</h3><p>该方案本质上一个简单分离存储的内存分配方案:<br>分配器维护多个空闲链表, 每个空闲链表包含大小相等的空闲块 每个块的大小为这个大小类中最大元素的大小, 不分割不合并.    </p>
<p><img src="/images/objpools.png" alt="buddy_system">  </p>
<h4 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象池管理器</span><br><span class="line">  [对象A条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象B条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象C条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象D条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数</span><br></pre></td></tr></table></figure>

<p>单个条目指向的起始地址结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag|flag|flag : ...  FENCE SIZE: NODE SIZE :   FENCE SIZE: NODE SIZE :   ...</span><br></pre></td></tr></table></figure>
<p>条目指向的地址会首先保存flag标志标明该对象是否在使用中, 用于请求和释放时候的判定标志<br>NODE SIZE会进行8字节对齐, FENCE SIZE也选择8字节 这样整个对象池的地址都是保证8字节对齐的<br>FENCE写入特殊固定的魔法数值 用于溢出检测<br>分配出去的对象 NODE SIZE的起始地址即为对象的地址<br>空闲的对象, 其NODE SIZE的第一个U32保存的是下一个空闲内存 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: NODE SIZE: 对应下面结构</span><br><span class="line">: FREE IDX, NODE SIZE- FENCE SIZE:</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/07/2020-02-03-shared-memory-resume-overview/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2019/12/17/2019-12-17-elf-load/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/17/2019-12-17-elf-load/" itemprop="url">ELF装载和动态链接过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-17T00:00:00+08:00">
                2019-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="1-目录"><a href="#1-目录" class="headerlink" title="..1. 目录"></a>..1. 目录</h3><!-- TOC -->

<ul>
<li><a href="#目录">目录</a><ul>
<li><a href="#动态链接过程">动态链接过程</a><ul>
<li><a href="#基础宏定义">基础宏定义</a></li>
<li><a href="#重定位定义">重定位定义</a></li>
<li><a href="#符号表定义">符号表定义</a></li>
<li><a href="#动态段定义">动态段定义</a></li>
<li><a href="#rscopeelem-定义">rscopeelem 定义</a></li>
<li><a href="#linkmap">linkmap</a></li>
<li><a href="#dlfixup-函数定义和分析">dlfixup 函数定义和分析</a></li>
<li><a href="#符号版本">符号版本</a></li>
<li><a href="#强弱符号">强弱符号</a></li>
<li><a href="#强弱引用">强弱引用</a></li>
<li><a href="#符号的作用域">符号的作用域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#动态库装载过程">动态库装载过程</a><ul>
<li><a href="#elf的辅助向量-auxv">ELF的辅助向量 AUXV</a></li>
<li><a href="#elf的装载有三种方法">ELF的装载有三种方法</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/17/2019-12-17-elf-load/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2019/12/16/2019-12-16-elf-link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/16/2019-12-16-elf-link/" itemprop="url">ELF静态链接过程和动态链接过程中的GOT表的作用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-16T00:00:00+08:00">
                2019-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <font color=#ff6688>  

<h3 id="1-目录"><a href="#1-目录" class="headerlink" title="..1. 目录"></a>..1. 目录</h3><!-- TOC -->

<ul>
<li><a href="#1-目录">..1. 目录</a></li>
<li><a href="#2-准备工具和基础汇编知识">..2. 准备工具和基础汇编知识</a></li>
<li><a href="#3-编译链接过程的基本原理和流程">..3. 编译链接过程的基本原理和流程</a><ul>
<li><a href="#31-gcc中编译一个源文件可以拆分为4个部分">..3.1. gcc中编译一个源文件可以拆分为4个部分</a></li>
<li><a href="#32-编译单元translation-environment-编译的转换阶段-">..3.2. 编译单元(Translation environment), 编译的转换阶段 :</a></li>
<li><a href="#33-pic-pie-位置无关代码">..3.3. PIC PIE 位置无关代码</a></li>
<li><a href="#34-got-plt-全局偏移表-链接过程表">..3.4. GOT PLT 全局偏移表 链接过程表</a></li>
<li><a href="#35-符号表和符号">..3.5. 符号表和符号</a><ul>
<li><a href="#351-全局符号和局部符号">..3.5.1. 全局符号和局部符号</a></li>
<li><a href="#352-外部符号和内部符号">..3.5.2. 外部符号和内部符号</a></li>
<li><a href="#353-和字符串表的关系">..3.5.3. 和字符串表的关系</a></li>
</ul>
</li>
<li><a href="#36-静态链接过程">..3.6. 静态链接过程</a></li>
<li><a href="#37-动态链接过程">..3.7. 动态链接过程</a></li>
</ul>
</li>
<li><a href="#4-跟踪调测">..4. 跟踪调测</a><ul>
<li><a href="#41-测试源码">..4.1. 测试源码</a></li>
<li><a href="#42-位置有关的重定位分析">..4.2. 位置有关的重定位分析</a><ul>
<li><a href="#421-分析结论如下">..4.2.1. 分析结论如下:</a></li>
<li><a href="#422-系统源码参考">..4.2.2. 系统源码参考:</a></li>
<li><a href="#423-字符串数据">..4.2.3. 字符串数据</a></li>
<li><a href="#424-节信息">..4.2.4. 节信息</a></li>
<li><a href="#425-text数据">..4.2.5. text数据</a></li>
</ul>
</li>
<li><a href="#43-位置无关的重定位分析">..4.3. 位置无关的重定位分析</a><ul>
<li><a href="#431-分析说明">..4.3.1. 分析说明</a></li>
<li><a href="#432-全局数据访问代码分析">..4.3.2. 全局数据访问代码分析</a></li>
<li><a href="#433-全局函数访问代码分析">..4.3.3. 全局函数访问代码分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#动态库装载过程">动态库装载过程</a><ul>
<li><a href="#elf的辅助向量-auxv">ELF的辅助向量 AUXV</a></li>
<li><a href="#load_elf_binary函数">load_elf_binary函数</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h3 id="2-准备工具和基础汇编知识"><a href="#2-准备工具和基础汇编知识" class="headerlink" title="..2. 准备工具和基础汇编知识"></a>..2. 准备工具和基础汇编知识</h3><ul>
<li>readelf -a  查看elf信息  </li>
<li>objdump -S 查看汇编指令  </li>
<li>ldd 查看动态加载   </li>
<li>xxd - make a hexdump or do the reverse.</li>
<li>gdb  <ul>
<li>gdb 通过<code>layout regs</code>打开寄存器显示, 通过<code>set disassemble-next-line on</code>打开汇编  </li>
<li>gdb 通过peda插件字节显示汇编和寄存器  和上面的原生方式选择一个即可    </li>
<li>gdb关闭ASLR：<ul>
<li>set disable-randomization on</li>
</ul>
</li>
<li>开启ASLR：<ul>
<li>set disable-randomization off</li>
</ul>
</li>
<li>查看ASLR状态：<ul>
<li>show disable-randomization</li>
</ul>
</li>
<li>disas反汇编命令，直接disas是反汇编当前函数<ul>
<li>disas /r (显示汇编指令对应十六进制值)   </li>
<li>disas /m (如果有源码，显示对应行源码)   </li>
</ul>
</li>
<li>intel语法<ul>
<li>set disassembly-flavor intel</li>
<li>set disassembly-flavor att  </li>
</ul>
</li>
</ul>
</li>
<li>详细工具和汇编的基础知识见上一篇文章: <a href="https://zsummer.github.io/2019/12/11/2019-12-11-asm-syntax/">汇编语法/寻址/寄存器/代码模型(GNU assembler) </a>  </li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/16/2019-12-16-elf-link/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2019/12/11/2019-12-11-asm-syntax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/11/2019-12-11-asm-syntax/" itemprop="url">汇编语法/寻址/寄存器/代码模型(GNU assembler)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-11T00:00:00+08:00">
                2019-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="0-0-1-目录"><a href="#0-0-1-目录" class="headerlink" title="0.0.1. 目录"></a>0.0.1. 目录</h3><!-- TOC -->

<ul>
<li><a href="#目录">目录</a></li>
<li><a href="#基础语法格式">基础语法格式</a></li>
<li><a href="#常见寄存器以及作用">常见寄存器以及作用</a><ul>
<li><a href="#通用寄存器">通用寄存器</a><ul>
<li><a href="#寄存器使用惯例-原文">寄存器使用惯例 原文</a></li>
<li><a href="#中文对照">中文对照</a></li>
</ul>
</li>
<li><a href="#专用寄存器">专用寄存器</a><ul>
<li><a href="#标志寄存器-rflags">标志寄存器 RFLAGS</a></li>
<li><a href="#程序计数器pcrelative-instruction-pointerip">程序计数器(PC)(Relative Instruction-Pointer)(IP)</a></li>
<li><a href="#指令寄存器">指令寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#汇编语法">汇编语法</a><ul>
<li><a href="#汇编指令">汇编指令</a></li>
<li><a href="#操作数格式与寻址">操作数格式与寻址</a><ul>
<li><a href="#内存操作数">内存操作数</a></li>
<li><a href="#寻址模式">寻址模式</a></li>
<li><a href="#large-code-mode">large code mode:</a></li>
<li><a href="#共享库中对g_static_so_data的访问">共享库中对g_static_so_data的访问</a></li>
<li><a href="#small-code-mode">small code mode:</a></li>
<li><a href="#备注说明">备注说明</a></li>
<li><a href="#relro--relocation-read-only">RELRO  Relocation Read Only</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#调用惯例calling-conventions">调用惯例Calling Conventions</a><pre><code>- [参数压栈顺序](#参数压栈顺序)
    - [Caller Save和Callee Save](#caller-save和callee-save)</code></pre></li>
<li><a href="#工具">工具</a><ul>
<li><a href="#peda插件">PEDA插件</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->




<h3 id="0-0-2-基础语法格式"><a href="#0-0-2-基础语法格式" class="headerlink" title="0.0.2. 基础语法格式"></a>0.0.2. 基础语法格式</h3><p>GAS汇编的格式阅读起来很自然 如下   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[操作符]    [源]      [目标]   </span><br><span class="line">movl        $0,      -4(%rbp)</span><br></pre></td></tr></table></figure>


<p>但是INTEL格式更贴近C语言的书写风格   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[操作符]   [目标]    [源]  </span><br><span class="line">mov        esi,     DWORD PTR [rbp-0x4]</span><br></pre></td></tr></table></figure>

<p>很像C语言的代码   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int esi &#x3D; *(rbp-0x4);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本文基于X86-64架构体系整理了GAS风格的汇编语法, 如无特殊说明后续内容皆以环境为准.    </p>
</blockquote>
<p>“@”符号表示“将符号左边的变量钳制在符号右边的地址   </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/11/2019-12-11-asm-syntax/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2019/11/29/2019-12-06-is-a-and-has-a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/29/2019-12-06-is-a-and-has-a/" itemprop="url">AS-A 和 HAS-A 概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-29T00:00:00+08:00">
                2019-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3><span id="目录">目录</span></h3><hr>
<!-- TOC -->

<ul>
<li><a href="#目录">目录</a></li>
<li><a href="#词的关系概括">词的关系概括</a><ul>
<li><a href="#polysemy-词汇蕴含规则">polysemy 词汇蕴含规则</a><ul>
<li><a href="#linear-polysemy-线性多义">linear polysemy 线性多义</a></li>
<li><a href="#non-linear-polysemy-非线性多义">non-linear polysemy 非线性多义</a></li>
<li><a href="#一词多义">一词多义</a></li>
</ul>
</li>
<li><a href="#hyperonymhyponym-上下义关系">hyperonym–hyponym 上下义关系</a></li>
<li><a href="#autonymy-反义关系">autonymy 反义关系</a></li>
<li><a href="#synonymy-同义关系">synonymy 同义关系</a></li>
</ul>
</li>
<li><a href="#语义聚合关系">语义聚合关系</a><ul>
<li><a href="#上下义词">上下义词</a></li>
<li><a href="#总分词">总分词</a></li>
<li><a href="#类义词狭义">类义词(狭义)</a></li>
</ul>
</li>
<li><a href="#面向对象中的关系">面向对象中的关系</a><ul>
<li><a href="#类型和实例关系">类型和实例关系</a></li>
<li><a href="#hyperonymhyponym-supertypesubtype-上下义关系-超类子类关系--is-a-关系-继承泛化关系">hyperonym–hyponym (supertype–subtype) 上下义关系, 超类子类关系  IS-A 关系 继承/泛化关系</a></li>
<li><a href="#holonymmeronym--整体部分关系-has-a-关系">holonym–meronym  整体部分关系 HAS-A 关系</a></li>
</ul>
</li>
<li><a href="#集合关系">集合关系</a></li>
</ul>
<!-- /TOC -->
<h3><span id="词的关系概括">词的关系概括</span></h3><h4><span id="polysemy-词汇蕴含规则">polysemy 词汇蕴含规则</span></h4><h5><span id="linear-polysemy-线性多义">linear polysemy 线性多义</span></h5><ul>
<li>autohyponymy, where the basic sense leads to a specialised sense  基本意义-&gt;特殊意义  </li>
<li>automeronymy, where the basic sense leads to a subpart sense 基本意义-&gt;部分意义  整体-&gt;局部  </li>
<li>autohyperonymy or autosuperordination, where the basic sense leads to a wider sense   基本意义-&gt;宽泛意义  下位-&gt;上位意义  </li>
<li>autoholonymy, where the basic sense leads to a larger sense  基本意义-&gt;更多意义 <h5><span id="non-linear-polysemy-非线性多义">non-linear polysemy 非线性多义</span></h5></li>
<li>metonymy  转喻 借喻    </li>
<li>metaphor 隐喻  <h5><span id="一词多义">一词多义</span></h5></li>
<li>原始意义与衍生意义(派生)   </li>
<li>普通意义与特殊意义  </li>
<li>抽象意义与具体意义  </li>
<li>字面意义与比喻意义  <h4><span id="hyperonymhyponym-上下义关系">hyperonym–hyponym 上下义关系</span></h4><h4><span id="autonymy-反义关系">autonymy 反义关系</span></h4><h4><span id="synonymy-同义关系">synonymy 同义关系</span></h4></li>
</ul>
<h3><span id="语义聚合关系">语义聚合关系</span></h3><h4><span id="上下义词">上下义词</span></h4><p>上下义关系代表了概念上的蕴含关系, 或者说在类型层级上, 下位类一定带有上位类的所有属性.  可以用 IS A 来表达.  </p>
<p>例如 上义词 水果  下义词 香蕉.  香蕉 IS A 水果  但是不能反过来说 水果 IS A  香蕉   </p>
<p>上下义关系也可以进入 ‘A包含B’的格式,  比如说香蕉包含水果的属性  </p>
<h4><span id="总分词">总分词</span></h4><p>整体部分关系   用HAS A来表达  </p>
<p>例如 门  和  门套/门板    可以进入’A包含B’的格式 但是不能用  ‘B是A’的格式   </p>
<h4><span id="类义词狭义">类义词(狭义)</span></h4><p>多元关系中的同级词语  例如门下的 门套和门板的关系  </p>
<h3><span id="面向对象中的关系">面向对象中的关系</span></h3><h4><span id="类型和实例关系">类型和实例关系</span></h4><ul>
<li>Type–token distinction  例如一个语句中  rose is a rose 中有三个type 4个token   <ul>
<li>type == classes  </li>
<li>object == instances ==token  </li>
</ul>
</li>
<li>type of    <ul>
<li>(实例)的类型     </li>
</ul>
</li>
<li>instance of   <ul>
<li>(类型) 的实例  </li>
</ul>
</li>
</ul>
<h4><span id="hyperonymhyponym-supertypesubtype-上下义关系-超类子类关系-is-a-关系-继承泛化关系">hyperonym–hyponym (supertype–subtype) 上下义关系, 超类子类关系  IS-A 关系 继承/泛化关系</span></h4><ul>
<li>子类包含所有超类的属性/方法 可以用 “子类 IS A 父类” 来进行判定和使用   </li>
<li>所有可以对超类适用的规范同样也可以适用于其子类   <ul>
<li>李氏替换原则<ul>
<li>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.  </li>
<li>使用基类对象指针或引用的函数必须能够在不了解衍生类的条件下使用衍生类的对象   </li>
<li>李氏替换原则中 避免重写父类的非抽象方法, 而多态的实现是通过重写抽象方法实现.   </li>
<li>面向对象中的抽象方法是定义方法的声明规范而不约束其实现因此扔可 概括为上句 “ 所有可以对超类适用的规范同样也可以适用于其子类”   </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><span id="holonymmeronym-整体部分关系-has-a-关系">holonym–meronym  整体部分关系 HAS-A 关系</span></h4><ul>
<li><p>aggregation 聚合关系  不存在所属权  HAS-A 关系  </p>
<ul>
<li>部分可以脱离/超出整体的生命周期独立存在 比如家庭成员和家庭  玩家和工会  </li>
</ul>
</li>
<li><p>composition 组成关系  存在所属权  PART-OF| HAS-A 关系 </p>
<ul>
<li>部分不可以脱离整体的生命周期管理 比如四肢和人体  </li>
<li>对于编程来讲, 我们实例化玩家对象, 实例化背包对象, 玩家下线需要连带清理背包对象.   </li>
</ul>
</li>
<li><p>containment 包含关系   member-of | contains-a | part-of|HAS-A 关系  </p>
<ul>
<li>对成员的访问必须经过整体  成员为内涵状态  </li>
<li>对于C++来说 privete:下的数据成员必须使用该类的接口访问  </li>
<li>例如玩家对象和玩家的等级属性  </li>
</ul>
</li>
</ul>
<h3><span id="集合关系">集合关系</span></h3><p>从更抽象的角度来说<br>IS-A的关系判定为  A 是不是 B的特化 (specialization)<br>从集合关系来讲则为 A ⊃ B   A是不是B的真超集   </p>
<p>HAS-A的关系判定为 B 是不是 A的组成部分<br>从集合关系来讲则为 B ⊂ A         B 是不是A的的真子集   </p>
<p>ALIAS-A (没有这个术语) 的关系则是 A = B 即 别名.   </p>
<p>从集合角度来讲, 如果B是A的特化, 那么A同时也是B的构成,  即:</p>
<ul>
<li>B ⊃ A(IS-A) 可以推导出 A ⊂ B (HAS-A)  </li>
<li>但是IS-A限定了 A ⊂ B(HAS-A) 不可以推导出B ⊃ A (IS-A)     (IS-A限定特化后具有相同的拓扑结构)</li>
</ul>
<p>因此</p>
<p>这IS-A这种关系 是 HAS-A 的特化.  即  IS-A  ⊃ HAS-A </p>
<p>换成具体到OO语言里,  继承是一种特殊的聚合方式.<br>聚合更具有一般化的性质 更松散  </p>
<p>因此 IS-A  is a  HAS-A  通过IS-A到HAS-A的转化可获得更好的一般性(泛化)  泛化转关联本身也是一种泛化</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2019/11/29/2019-11-29-static-linking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/29/2019-11-29-static-linking/" itemprop="url">静态链接过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-29T00:00:00+08:00">
                2019-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr>
<!-- TOC -->

<ul>
<li><a href="#目录">目录</a></li>
<li><a href="#基本编译链接流程">基本编译链接流程</a></li>
<li><a href="#静态链接过程概述">静态链接过程概述</a></li>
<li><a href="#静态链接过程流程追踪和代码验证">静态链接过程流程追踪和代码验证</a><ul>
<li><a href="#测试源代码">测试源代码</a></li>
<li><a href="#生成汇编代码-从这里开始会有两个分支代码-non-pic-和-pic对照">生成汇编代码 (从这里开始会有两个分支代码 NON-PIC 和 PIC对照)</a><ul>
<li><a href="#汇编代码-相对位置版本">汇编代码 (相对位置版本)</a></li>
<li><a href="#汇编代码-位置无关版本">汇编代码 (位置无关版本)</a></li>
</ul>
</li>
<li><a href="#生成elf的可重定位文件">生成ELF的可重定位文件</a><ul>
<li><a href="#可重定向文件和汇编指令-相对位置版本">可重定向文件和汇编指令 (相对位置版本)</a></li>
<li><a href="#可重定向文件和汇编指令-位置无关版本">可重定向文件和汇编指令 (位置无关版本)</a></li>
</ul>
</li>
<li><a href="#链接为可执行文件或者共享库">链接为可执行文件(或者共享库)</a><ul>
<li><a href="#可执行文件-相对位置的非pieexec版本">可执行文件 (相对位置的非PIE(EXEC)版本)</a></li>
<li><a href="#可执行文件-相对位置的piedyn版本">可执行文件 (相对位置的PIE(DYN)版本)</a></li>
<li><a href="#可执行文件-位置无关的非pieexec版本">可执行文件 (位置无关的非PIE(EXEC)版本)</a></li>
<li><a href="#可执行文件-位置无关的piedyn版本">可执行文件 (位置无关的PIE(DYN)版本)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h3 id="基本编译链接流程"><a href="#基本编译链接流程" class="headerlink" title="基本编译链接流程"></a>基本编译链接流程</h3><ul>
<li>编译并输出汇编代码  <ul>
<li>g++ -S lib.cpp -o lib.s </li>
</ul>
</li>
<li>打包成ELF可重定位文件 ELF TYPE= ET_REL  即.o文件  <ul>
<li>g++ -c lib.s -o lib.o </li>
</ul>
</li>
<li>链接到动态库或者可执行文件<ul>
<li>g++ lib.o -o a.out   </li>
<li>g++ -shared lib.o -o a.out </li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/11/29/2019-11-29-static-linking/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="夏天" />
          <p class="site-author-name" itemprop="name">夏天</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">夏天</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
