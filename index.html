<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="关于夏天的一切">
<meta property="og:url" content="https://zsummer.github.io/index.html">
<meta property="og:site_name" content="关于夏天的一切">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="夏天">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zsummer.github.io/"/>





  <title>关于夏天的一切</title>
  














<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">关于夏天的一切</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我总觉得对你的爱很美</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/08/11/2020-08-11-shm-allocator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/11/2020-08-11-shm-allocator/" itemprop="url">一种适合共享内存RESUME方案的通用内存分配器设计方案和实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-11T00:00:00+08:00">
                2020-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC -->

<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">基本原理</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">内存分配器的基本概念</a><ul>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E5%BC%8F%E5%88%86%E9%85%8D%E5%99%A8">显示和隐式分配器</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82%E5%92%8C%E7%9B%AE%E6%A0%87">设计要求和目标</a><ul>
<li><a href="#%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E5%92%8C%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98">内部碎片和外部碎片问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E7%A1%80%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">基础分配策略</a><ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">基础存储方式</a><ul>
<li><a href="#sequential-fit--%E8%BF%9E%E7%BB%AD%E9%80%82%E9%85%8D">Sequential Fit  连续适配</a></li>
<li><a href="#segregated-list-%E5%88%86%E7%A6%BB%E5%88%97%E8%A1%A8">Segregated List 分离列表</a></li>
<li><a href="#indexed--fit">Indexed  Fit</a></li>
</ul>
</li>
<li><a href="#%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E7%AD%96%E7%95%A5">路径匹配策略</a><ul>
<li><a href="#best-fit">Best fit</a></li>
<li><a href="#worst-fit">Worst fit</a></li>
<li><a href="#first-fit">First fit</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88">设计方案</a><ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E9%9C%80%E6%B1%82">设计需求:</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F">设计方式:</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E6%A8%A1%E5%92%8C%E6%9C%80%E7%BB%88%E6%80%A7%E8%83%BD">代码规模和最终性能</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的文章我比较全面的介绍了一个完整的resume机制的阐述, 也提到了一些开发成本和三方库移植的问题, 这篇文章主要介绍如何在共享内存上实现一套可动态扩容的通用内存分配器, 以及如何利用通用内存分配器进行三方库包括stl中容器类的快速resumable化.       </p>
<p>通用动态内存分配器的实现可以很好的对共享内存RESUME机制进行一个补充,  例如可以简单的基于分配器实现stl的allocator, 从而直接得到resumable的vector, list, queue, map, multi_map, unorder_map等;   也可以简单的将一些本身就比较容易resumable化的三方库和算法替换其allocator来简单快速的完成移植工作而非重写他们.   例如常见的资源解析rapidxml   移动避免算法库rvo等  .  </p>
<p>当然, 处理易用性和快速移植三方库这些优点外, 从项目角度考虑也有一些缺点需要关注并进行合理范围的使用.   </p>
<p>相比静态内存机制下的resumable方案 </p>
<ul>
<li><p>较难估算内存峰值用量  </p>
<ul>
<li>有些场合下该难点是业务需求带来的, 比如说我们普通玩家可以设置可绑定的上限buff100个就够用, 但是对于一些GVE的大型BOSS团本来说, 100个就容易超限,  在扁平化的设计中, 如果我们用静态内存方案那么所有单位的内存使用量都是’上限’, 但是改成动态方案 则是根据真实情况动态波动的.  我们可以根据策划配置通过软上限来进行计算, 但是业务功能量级铺设上来后 则很难全面的评估这些地方对内存使用的真实情况.     </li>
<li>静态内存中在启服时可以一次性的计算好所有内存大小, 整个游戏无论负载情况其内存占用是始终稳定且直观的 .   </li>
</ul>
</li>
<li><p>内存安全性不如静态内存   </p>
<ul>
<li>静态内存基本上不存在野指针 越界等问题  也不存在内存不够用的情况   </li>
<li>例如说我实现了<code>static_list</code>; <ul>
<li>定义声明了OBJ和总大小 <code>static_list&lt;Buff, MAX_BUFF_SIZE&gt; buffs;</code>  </li>
<li>然后我引用了一个指针指向其中一个已有的元素进行当前被动动作标记, 在受击出现的时候<code>Buff* act = &amp;受击BUFF;</code>  在受击结束时候在移除act;  这里虽然用到了指针 但是在使用的时候, static_list中所有的元素都在一个连续的静态内存区域内, 并且该指针可以通过偏移检测和bitmap计算是否是有效的obj指针, obj是不是有效的buff等, 并不会因为是指针出现越界访问问题.  </li>
</ul>
</li>
</ul>
</li>
<li><p>定位一些内存访问相关的问题可能会更麻烦一些   </p>
<ul>
<li>例如:  所有战斗单位位于共享内存xxx–yyy地址内以大小X对齐, 每个单位内聚合有技能模块移动模块属性模块.  假如现在出现了一个读取属性错误的问题, 我们很容易根据有限的地址信息去推测出出问题的范围, 并且方便进行基于内存地址的修改情况进行监听断点等  </li>
</ul>
</li>
<li><p>性能相比静态方案一般会有性能上的损失,  动态内存的分配和回收有一个适配的成本开销.   </p>
</li>
<li><p>长期运行可能有内存碎片问题</p>
<ul>
<li>这个问题反而比较乐观, 因为在静态内存池方案上 内存利用率往往是非常低的, 而动态内存分配器的碎片率一般根据情况大约都控制在25%以下, 像dlmalloc则在实践中能控制在95%左右.  </li>
<li>静态内存一般来说, 对象池与对象池之间是内存隔离的, 即相互之间的空闲内存不能共用    </li>
<li>无论是对象池还是容器, 其规模都是直接以’上限’在定义阶段确定的, 一般情景下都会有大量的富余容量浪费  </li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/08/11/2020-08-11-shm-allocator/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/08/03/2020-08-03-shm-resume/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/03/2020-08-03-shm-resume/" itemprop="url">共享内存RESUME机制综述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-03T00:00:00+08:00">
                2020-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- TOC -->

<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98resume%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98resume%E8%80%8C%E4%B8%8D%E6%98%AF%E9%9B%86%E7%BE%A4%E5%86%97%E4%BD%99%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">共享内存RESUME出现的背景: 为什么选择共享内存RESUME而不是集群冗余+故障转移</a><ul>
<li><a href="#mmoact%E7%9B%B8%E6%AF%94%E4%BC%A0%E7%BB%9F%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E5%BC%82%E5%90%8C">MMOACT相比传统互联网的异同</a></li>
<li><a href="#%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E5%92%8C%E5%86%B3%E7%AD%96">方案对比和决策</a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E5%92%8C%E9%AA%8C%E8%AF%81">可行性分析和验证</a><ul>
<li><a href="#%E9%9A%94%E7%A6%BB%E4%B8%9A%E5%8A%A1%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E4%B8%8E%E9%9D%9E%E4%B8%9A%E5%8A%A1%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE">隔离业务状态数据与非业务环境数据</a></li>
<li><a href="#%E9%9A%94%E7%A6%BB%E4%B8%9A%E5%8A%A1%E7%8A%B6%E6%80%81%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E5%92%8C%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB">隔离业务状态和业务逻辑数据和逻辑分离</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E9%AA%8C%E8%AF%81-first-global-state">最小化验证, FIRST GLOBAL STATE</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E5%AE%9E%E8%B7%B5">解决方案和实践</a><ul>
<li><a href="#resume%E7%8A%B6%E6%80%81%E9%87%8D%E5%BB%BA%E6%81%A2%E5%A4%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98">RESUME状态重建/恢复的基础问题</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5">基础问题以及解决策略</a><ul>
<li><a href="#%E9%99%84-%E5%9C%A8%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%9A%84aslr%E4%B8%AD%E7%A1%AE%E7%AB%8B%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">附: 在随机化的ASLR中确立确定性的地址空间</a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%92%8C%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8%E7%AD%89%E9%80%9A%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1">对象池和基础容器等通用性设计</a><ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%AE%9A%E9%95%BF%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%9B%9E%E6%94%B6%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1">对象池定长内存池+对象分配回收接口的基础设计</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0">地址无关的容器实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a><ul>
<li><a href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">需要注意的其他问题</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E6%80%A7%E4%B8%8A%E7%9A%84%E6%8C%91%E6%88%98-%E5%9C%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8A%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8">通用性上的挑战: 在共享内存上构建通用内存管理器</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>共享内存RESUME机制是指的: 通过将游戏状态数据保存在共享内存中, 当游戏进程crash后通过重启游戏服务器并attach已有的共享内存来恢复游戏状态, 以此达到玩家游戏体验在出现宕机时的连贯性, 提升游戏的容灾能力.</strong>       </p>
<h2 id="共享内存RESUME出现的背景-为什么选择共享内存RESUME而不是集群冗余-故障转移"><a href="#共享内存RESUME出现的背景-为什么选择共享内存RESUME而不是集群冗余-故障转移" class="headerlink" title="共享内存RESUME出现的背景: 为什么选择共享内存RESUME而不是集群冗余+故障转移"></a>共享内存RESUME出现的背景: 为什么选择共享内存RESUME而不是集群冗余+故障转移</h2><h3 id="MMOACT相比传统互联网的异同"><a href="#MMOACT相比传统互联网的异同" class="headerlink" title="MMOACT相比传统互联网的异同"></a>MMOACT相比传统互联网的异同</h3><p>在web领域中,  业务和数据分离, 从而达成’业务无状态化’, 开发人员专注于业务本身, 状态数据的一致性问题和容灾问题转移到可以较为独立解决的数据存储领域, 这个领域有非常多的论文和解决方案, 以及成熟的服务等.     </p>
<p>而对于游戏领域来说, 互联网成熟的解决的方案很难在这个地方应用,  当然 对于外围系统来说, 我们仍然可以按照互联网成熟的解决方案进行布局, 例如聊天系统, 好友系统,  邮件系统, 日志系统,  或者一些游戏中的公会系统等.     </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/08/03/2020-08-03-shm-resume/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/07/24/2020-07-24-state_sync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/24/2020-07-24-state_sync/" itemprop="url">多人游戏中的同步机制综述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-24T00:00:00+08:00">
                2020-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!-- toc -->

<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#同步问题的产生和基本策略机制">同步问题的产生和基本策略机制</a></li>
<li><a href="#同步模型的一般性描述">同步模型的一般性描述</a></li>
<li><a href="#游戏中的状态一致性问题">游戏中的状态一致性问题</a></li>
<li><a href="#同步过程中的抖动和延迟问题">同步过程中的抖动和延迟问题</a></li>
<li><a href="#优化网络延迟和抖动">优化网络延迟和抖动</a><ul>
<li><a href="#当前的网络环境">当前的网络环境</a></li>
<li><a href="#工具">工具</a></li>
<li><a href="#链路层延迟的优化">链路层延迟的优化</a></li>
<li><a href="#tcp还是udp">TCP还是UDP</a></li>
<li><a href="#tcp下的延迟和抖动优化">TCP下的延迟和抖动优化</a></li>
<li><a href="#udp的优化">UDP的优化</a></li>
</ul>
</li>
<li><a href="#时钟选择和时钟同步">时钟选择和时钟同步</a><ul>
<li><a href="#实现">实现</a></li>
</ul>
</li>
<li><a href="#移动-影子跟随算法和优化内插">移动: 影子跟随算法和优化(内插)</a></li>
<li><a href="#常见的延迟隐藏手段">常见的延迟隐藏手段</a></li>
<li><a href="#移动-航位推测法外推">移动: 航位推测法(外推)</a></li>
<li><a href="#插值和外推-以及常用算法">插值和外推, 以及常用算法</a><ul>
<li><a href="#内插值常用算法">内插值常用算法</a></li>
<li><a href="#外插值常用算法">外插值常用算法</a></li>
</ul>
</li>
<li><a href="#命中-延迟补偿">命中: 延迟补偿</a><ul>
<li><a href="#延迟补偿的局限">延迟补偿的局限</a></li>
</ul>
</li>
<li><a href="#逻辑预演和客户端提交命中">逻辑预演和客户端提交命中</a><ul>
<li><a href="#满足进攻者的精彩时刻">满足进攻者的精彩时刻</a></li>
</ul>
</li>
<li><a href="#提高tickrate">提高TickRate</a></li>
<li><a href="#回退-快播-和解">回退 快播 和解</a></li>
<li><a href="#案例分析部分">案例分析部分</a></li>
<li><a href="#引用文献">引用文献</a></li>
</ul>
<!-- tocstop -->

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文中所有内容默认都基于逻辑描述, 逻辑状态,逻辑处理的逻辑游戏世界,  纯本地表现类, 总是通过逻辑世界单向导出的渲染计算等, 均不在本篇文章讨论范畴.  </p>
<h2 id="同步问题的产生和基本策略机制"><a href="#同步问题的产生和基本策略机制" class="headerlink" title="同步问题的产生和基本策略机制"></a>同步问题的产生和基本策略机制</h2><p><strong>在多人游戏或者基于CS网络模型的游戏中, 玩家所在的游戏世界并非全由本地生成和修改, 必须不断从服务器或者其他玩家获得最新的信息来完成游戏世界的共享体验, 在多人实时交互的游戏中,  相当于每个人都维护一个’完整世界’的副本, 并保证每个人维护的副本之间一致性和实时性, 不同游戏对副本的规模复杂度以及对一致性和实时性的要求不同, 并随着网络环境的变化在不同的历史时期下演化出了多种同步方案.</strong>   </p>
<p>在所有的同步方案中, 有两种最基础也最常见的同步机制, 即状态同步和帧同步, 其基本机制和区别为:  </p>
<ul>
<li><strong>状态同步: 通过同步游戏中的各种状态来保证游戏世界副本的一致性, 基本流程如下:</strong>   <ul>
<li>服务器维护权威完整副本  客户端维护本地副本 <font color=#ccc> (可以只维护部分副本) </font>   </li>
<li>客户端上行请求到服务器 服务器进行完整的逻辑演算 并将发生改变的状态下行给客户端   </li>
<li><font color=#ccc>客户端基于本地副本进行预演和状态预刷新 </font>  </li>
<li>客户端用来自服务器的状态数据刷新本地副本, 对齐服务器副本   <ul>
<li><font color=#ccc>客户端如果有因预演导致的数据不对齐需要通过强同步/回滚/和解等机制达成最终对齐</font>   <ul>
<li><font color=#ccc>快照类同步方式总是全量对齐</font>   </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>帧同步: 泛指通过一致的初始状态, 一致的输入事件和一致的逻辑处理, 从而得到相同的计算结果来保证游戏世界副本的一致性的同步方案</strong>    </p>
<ul>
<li><p>该术语为泛指, 所有通过确定性算法,以保证输入一致来得出相同游戏流程结果的同步均可泛称为帧同步.   </p>
</li>
<li><p>最早有对等网络的锁步同步, 发展为非对等网络的主机锁步同步, 再到后来的bucket同步以及现在比较流行的定时不等待乐观帧同步  </p>
</li>
<li><p>锁步同步:  </p>
<ul>
<li>客户端定时(比如每五帧为一个关键帧)上传一轮输入信息   </li>
<li>服务器收到所有输入信息后广播给其他所有客户端  </li>
<li>客户端用服务器发来的更新消息中的输入信息进行游戏(如果是对称网络, 这个过程则是广播自己输入信息和搜集所有其他客户端的输入信息)     </li>
<li>如果客户端进行到下一个关键帧(5帧后)时没有收到服务器的更新消息则等待   </li>
<li>如果客户端进行到下一个关键帧时已经接收到了服务器的更新消息, 则将上面的数据用于游戏, 并采集当前鼠标键盘输入发送给服务器, 同时继续进行下去   </li>
<li>服务端采集到所有数据后再次发送下一个关键帧更新消息   </li>
</ul>
</li>
<li><p>定时不等待:     </p>
<ul>
<li>相对于锁步同步来说, 服务器会定时下发收集到的信息,  并根据收集到的信息调整关键帧的间隔,  没有在指定间隔内收到的消息会排在下一次关键帧或者丢弃   </li>
<li>相对于锁步同步来说, 任何客户端的卡顿不会阻塞其他玩家   </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>这两种同步模型本质上并不冲突, 并且在细节上会相互补充优化,  常见的为在状态同步这种弱一致性框架下添加确定性演算来增加同步的准确性, 在确定性的帧同步下隔离出来部分状态进行优化增加流畅性,  从模型角度来说, 在复杂的同步需求中, 状态同步总是比帧同步有更多的扩展和调优空间, 典型的案例如UE4和UNITY中的DS服务器.</strong>   </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/07/24/2020-07-24-state_sync/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/07/21/2020-07-21-math_of_combat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/2020-07-21-math_of_combat/" itemprop="url">数值模型 战斗属性和判定公式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-21T00:00:00+08:00">
                2020-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="战斗属性"><a href="#战斗属性" class="headerlink" title="战斗属性"></a>战斗属性</h2><p><strong>战斗属性属于战斗单位的简单数据字段,  提供基础的数据读写操作(相对于magic state而言).</strong><br>在实践中 一般战斗属性还包含从配置文件中load数据, 一级战斗属性到二级战斗属性的封装, 以及按照功能,战斗单位层级的划分等.    </p>
<h2 id="战斗属性的设计和实现"><a href="#战斗属性的设计和实现" class="headerlink" title="战斗属性的设计和实现"></a>战斗属性的设计和实现</h2><h3 id="字段表设计"><a href="#字段表设计" class="headerlink" title="字段表设计"></a>字段表设计</h3><p>字段表在设计上隶属于’接口层’这个概念, 简单直接, 易于访问和同步处理时目的.    </p>
<p>在C++中 通常考虑用一块静态数组的内存来表示   </p>
<table>
<thead>
<tr>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>字段名</td>
<td>HP</td>
<td>MP</td>
<td>ATK</td>
<td>CRIT</td>
<td>RESIST CRIT</td>
<td>HIT RATE</td>
<td>MISS RATE</td>
<td>…</td>
</tr>
<tr>
<td>转换类型</td>
<td>INT</td>
<td>INT</td>
<td>INT</td>
<td>INT</td>
<td>INT</td>
<td>FLOAT</td>
<td>FLOAT</td>
<td>…</td>
</tr>
</tbody></table>
<p>这种字段表的设计有以下优点和特性:</p>
<ul>
<li>性能非常高   </li>
<li>可以直接操作,遍历内存 方便统一管理  </li>
<li>以数组下标完成ID的设计, 并使用BIT位进行脏数据标记辅助进行增量同步  </li>
<li>初始化约定为0,  进行初始同步时只同步非0数据即可,  后续采用增量同步, 减少同步量   </li>
<li>字段表中的数据修改可以由属性表进行托管结算 也可以直接set   <ul>
<li>通常战斗属性均为属性表托管结算和刷新 不能直接set   </li>
<li>通常能量条类属性直接进行set </li>
<li>复杂的属性一般由多个属性功能完成 例如<ul>
<li>血量上限 (战斗属性)   </li>
<li>当前血量 (属于能量条类, 则特殊条件下以’血量上限属性’为依据进行set  例如出生满血)   </li>
</ul>
</li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/07/21/2020-07-21-math_of_combat/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/06/18/2020-06-18-skill-tag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/18/2020-06-18-skill-tag/" itemprop="url">技能系统中的标签机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-18T00:00:00+08:00">
                2020-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="技能系统中的标签机制"><a href="#技能系统中的标签机制" class="headerlink" title="技能系统中的标签机制"></a>技能系统中的标签机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>对于一个大规模系统的建模 一定离不开常见的分类手段, 而分类要根据系统中的元素以及元素之间的关系来作为划分依据, 从而采用不同策略<br>技能系统中的配置以’技能’和’效果’作为完整的配置单位, 所有的技能和效果之间的关系则是多维的图的拓扑关系的, 例如:</p>
<blockquote>
<p>眩晕BUFF: 禁止普通移动, 禁止常规技能释放,<br>定身BUFF: 禁止普通移动<br>金身BUFF: 禁止普通移动, 禁止所有技能释放,  不可被眩晕/禁止所有效果(受击, 伤害, debuff/buff等)<br>冰冻BUFF: 禁止普通移动, 禁止所有技能释放除了解控技能,  可能禁止受击<br>沉默BUFF:              禁止所有(部分)技能释放<br>无敌BUFF: 不接受任何伤害<br>霸体BUFF: 打断受击状态并免控<br>灯笼BUFF: 可困住霸体BUFF单位<br>解控技能: 接触被控状态但无法接触部分例如灯笼BUFF<br>净化技能: 移除DEBUFF<br>破盾技能: 移除带有指定盾效果的BUFF<br>致命一击: 突破所有防御包括部分无敌BUFF .<br>引导技能A: 可被强控技能打断<br>引导技能B: 可被移动取消<br>连招技能: 需要前置技能成功释放完成<br>千斤坠技能: 需要飞行状态可释放     </p>
</blockquote>
<p>几乎所有的技能和buff之间都需要定义好他们的交互关系, 包括依赖条件, 禁止状态,  打断逻辑,  替换规则, 触发节奏, 否则在不断的引入新的技能时, 很容易导致已有的系统出现局部甚至整体的错误流程和功能表现.   </p>
<p>而作为一个灵动丰富的多样性的技能系统, 在具体的状态关系上往往不会是简单的禁止打断逻辑, 而是分梯度, 计数, 浮动值的不同而有不同的分支策略, 需要对这样的一个规模和结构复杂的系统进行井井有条的管理和维护, 则需要一套完善灵活的拆分理念和管理机制.   </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/06/18/2020-06-18-skill-tag/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/06/18/2020-07-15-gcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/18/2020-07-15-gcd/" itemprop="url">技能系统中的输出循环和节奏控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-18T00:00:00+08:00">
                2020-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="技能系统中的循环控制"><a href="#技能系统中的循环控制" class="headerlink" title="技能系统中的循环控制"></a>技能系统中的循环控制</h1><h2 id="动作循环控制"><a href="#动作循环控制" class="headerlink" title="动作循环控制"></a>动作循环控制</h2><hr>
<ul>
<li>动作类技能, 普攻等依赖战斗单位身体动作的技能, 其受影响的身体部位不能同时做出两个动作   </li>
<li>根据技能的价值级别以及特色设计, 在可能导致冲突的两个动作之间需要明确打断关系    </li>
</ul>
<h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><p>无论是时间线的设计还是多段设计亦或是朴素的单段多子技能设计,  我们需要标记出每段动作的影响部位, 其意义是在于我们对所有技能通过打标记的形式来获得’技能与技能之间是否存在动作冲突’的信息.     </p>
<p>其次, 我们需要对冲突的技能之间的 重叠释放问题,  这里本质上是一个压制规则问题.   </p>
<ol>
<li>冲突的动作类技能一旦释放成功,  一定打断掉所有相关旧的技能</li>
<li>如果不做上下半身分离, 普通移动视为动作, 否则为下半身动作  </li>
<li>不希望被某些类型打断的时候  要禁止这些类型的技能释放 即压制类标签     </li>
</ol>
<p>举例来说   </p>
<ul>
<li><p>跳击技能:  </p>
<ul>
<li>技能类型:      上半身动作, 下半身动作  </li>
<li>前摇时间压制:  禁止普通移动 禁止下半身动作 禁止上半身动作   </li>
</ul>
</li>
<li><p>出拳技能   </p>
<ul>
<li>技能类型: 上半身动作   </li>
<li>前摇时间压制: 禁止上半身动作  </li>
</ul>
</li>
<li><p>闪避技能   </p>
<ul>
<li>技能类型: 上半身动作 下半身动作   </li>
<li>前摇时间压制: 禁止普通移动 禁止上半身移动 禁止下半身移动    </li>
</ul>
</li>
</ul>
<p>注意:  有些闪避是特色玩法  则需要额外的标签和流程来完成<br>闪避技能进行条件判定时先使用脚本进行预判, 如果当前存在会因动作压制闪避的技能 则先进行打断, 防止被压制<br>所有动作类技能额外添加是否可被闪避技能打断的标签,  单独完成闪避相关的压制处理.   </p>
<p>设计小结:   本质上动作类循环的控制, 在流程上首先是模拟动作状态机,  其次通过压制策略对状态机的切换策略进行控制    </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/06/18/2020-07-15-gcd/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/06/16/2020-06-16-lua-oop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/2020-06-16-lua-oop/" itemprop="url">游戏(技能)中的脚本设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-16T00:00:00+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="脚本设计"><a href="#脚本设计" class="headerlink" title="脚本设计"></a>脚本设计</h1><h2 id="前言和需求情景"><a href="#前言和需求情景" class="headerlink" title="前言和需求情景"></a>前言和需求情景</h2><p>每种语言都有自己的惯用思维, 面对领域需求时, 也应该在不同的语言思维环境下寻找解决方案, 而不是生搬硬套另外一种语言的特性, 但是从可计算性的角度上来看, 相同需求的良好解决方案往往具备很强的相似性.  </p>
<p>那么更具体的领域中, 我们说说技能系统的场景:  </p>
<p>技能系统的复杂度偏向问题域, 如果不去约束问题域的规模, 最好的解决方案一定是通过脚本化方式让技能的设计者直接去写设计者期望的战斗逻辑. 但是作为一门通用的语言, 是需要转化为一个简洁的, 低门槛的领域语言.  </p>
<p>这里不讨论如何拆解该系统所面对的问题域, 如何抽象出解决域的模型等, 这部分在之前的技能系统相关的PPT中已经描述过,  这里主要关注的是, 在使用脚本的情况下, 我们如何对脚本这部分进行更具体的设计.   </p>
<ul>
<li>作为开发者, 更关注的是开发测试成本, 即用最简洁的代码, 一劳永逸的提供最丰富的上层接口.   </li>
<li>作为设计者, 更关注的是是否提供了足够的封装, 隐藏掉不需要关心的功能实现细节以及流程细节, 并且能够总是通过简单的if else call来完成所有决策, 或者用简单的枚举或者画图 打钩完成所有决策而不需要操刀脚本编写.  </li>
</ul>
<ul>
<li>更进一步的, 从设计者角度, 按照配置的出场频度和复杂度应该有如下的方案选型排序:<font color=#f33 size=3>   <ul>
<li>几乎总是需要配置的:  默认配置方案,  什么都不需要做就是应该有的功能或者流程   </li>
<li>次高频:  通过开关来切换功能或者流程   </li>
<li>高频: 通过枚举来完成多功能或者多流程case   </li>
<li>高频低中度复杂: 通过枚举+固定的跟随参数来完成   </li>
<li>高频低中度复杂: 开发人员编写特定的功能模块, 条件模块, 并提炼出参数以特定枚举方式提供   </li>
<li></li>
<li>中低频复杂条件: 嵌入简短的脚本, 通过数据接口+脚本提供的布尔表达式来完成   </li>
<li>中低频复杂逻辑: 开发人员协助设计者编写脚本      </li>
<li>中低频中低复杂: 策划自行写脚本 自行验证  </li>
<li>低频其他: 脚本兜底实现  </font>    </li>
</ul>
</li>
</ul>
<ul>
<li><p>对于中小型硬核技能玩法项目  或者设计者本身有一定的编程功底, 那么我们可以实现一个简洁的脚本驱动的内核, 然后任由设计者天马行空的设计和铺展战斗系统.   </p>
</li>
<li></li>
<li><p>但对于另外一些情况, 比如存在大规模的低复杂度技能设计, 或者策划人员对脚本的接受能力参差不齐, 我们需要对脚本的适用范围进行收敛, 但是仍然想要灵活的机制来实现丰富的技能体系.  这就需要对涉及到脚本编写部分的更具体的优化设计.     </p>
<ul>
<li><p><font color=#f33 size=3>直接提高数据驱动部分的配置在整个技能系统下所包含的范围</font>   </p>
<blockquote>
<p>通过堆开发人力来提高.  但是这部分会随着需求的细化和新需求的提出导致不断的重构, 开发人员需要持续跟进<br>持续变更的核心代码会降低整个系统的稳定性, 因此这部分的工作需要克制,谨慎的拆解,分析,以及交付测试.   </p>
</blockquote>
</li>
<li><p><font color=#f33 size=3>把可以简单替换成脚本的逻辑, 给设计者提供数据驱动的配置接口, 在配表完成阶段或者读取配置阶段翻译成脚本</font>   </p>
<blockquote>
<p>相比上面的方案, 该方案不需要修改核心逻辑, 性能略有下降.   </p>
</blockquote>
</li>
<li><p><font color=#f33 size=3>提供脚本片段/脚本模版, 配置时候快速复用已有脚本逻辑</font>   </p>
<blockquote>
<p>相比上面一条, 该方案设计者可见脚本代码, 但是不需要手写.<br>不容易出错, 可以用来熏陶设计者对脚本的接受能力, 降低脚本门槛.   </p>
</blockquote>
</li>
<li><p><font color=#f33 size=3>提供脚本级别的封装机制, 对脚本复杂度进行降级</font>   </p>
<blockquote>
<p>把复杂的脚本实现拆解成独立的多段脚本函数, 一次测试多次复用<br>把多行脚本能完成事情 封装成一行脚本 或者一个函数+参数的形式<br>把简单的脚本映射成数据驱动的枚举+参数形式  (直接映射为封装好的函数+参数)<br>封装的位置单独存放在脚本文件中, 并且支持热更新方便快速试错和验证  </p>
</blockquote>
</li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/06/16/2020-06-16-lua-oop/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/05/09/2020-05-09-memory_alloctor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/2020-05-09-memory_alloctor/" itemprop="url">内存分配器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2><span id="内存分配器核心思想和算法">内存分配器核心思想和算法</span></h2><h3><span id="内存管理策略">内存管理策略</span></h3><h4><span id="sequential-fit-连续适配">Sequential Fit  (连续适配)</span></h4><p> 是基于一个单向或双向链表管理各个blocks的基础算法，因为和blocks的个数有关，性能比较差。这一类算法包括Fast-Fit, First-Fit, Next-Fit, and Worst-Fit。  </p>
<h4><span id="segregated-list-分离列表">Segregated List (分离列表)</span></h4><p> 将所有的空闲块，放入到一组链表中，每一个链表中只包含某一个大小范围的空闲块  </p>
<ul>
<li>Buddy System (Sequential Fit变种)  <ul>
<li>内部碎片化问题比较严重   </li>
<li>Binary Buddies  </li>
<li>Fibonacci Buddies  </li>
<li>Weighted Buddies   </li>
</ul>
</li>
</ul>
<h4><span id="indexed-fit">Indexed  Fit</span></h4><p> 通过一些高阶的数据结构来索引（Index）空闲的内存块。例如基于平衡树的“Best Fit”算法。</p>
<ul>
<li>使用Balanced Tree的Best Fit allocator</li>
<li>使用Cartesian tree 的Stephenson Fast-Fit allocator</li>
<li>Bitmap Fit (Indexed Fit 变种)<br>Indexed Fit算法的变种，通过一小段内存的位图来标记对应的内存是空闲的还是使用中。  </li>
</ul>
<h3><span id="路径匹配策略">路径匹配策略</span></h3><p>对于操作系统而言, 除了管理进程之外, 还需要有效的管理计算机的主内存, 管理主内存的共享使用和最小化内存访问时间是内存管理器的基本目标. 虽然使用了各种不同的策略来为争夺内存的进程分配空间，但最流行的三种策略是最佳匹配、最不适合匹配和首次匹配.    </p>
<ul>
<li>Best fit:<br>The allocator places a process in the smallest block of unallocated memory in which it will fit. For example, suppose a process requests 12KB of memory and the memory manager currently has a list of unallocated blocks of 6KB, 14KB, 19KB, 11KB, and 13KB blocks. The best-fit strategy will allocate 12KB of the 13KB block to the process.<br>最佳匹配:<br>这种匹配策略中, 分配器会从满足匹配要求的未分配内存中选择最小的块.<br>例如程序请求一个12kb的内存, 而当前的内存管理器有一个未分配的内存块列表, 分别为14k, 19k, 11k, 13k, 那么best-fit讲从13k的内存块中分配内存给程序.  </li>
</ul>
<ul>
<li><p>Worst fit:<br>The memory manager places a process in the largest block of unallocated memory available. The idea is that this placement will create the largest hold after the allocations, thus increasing the possibility that, compared to best fit, another process can use the remaining space. Using the same example as above, worst fit will allocate 12KB of the 19KB block to the process, leaving a 7KB block for future use.<br>最不适合匹配<br>内存管理器总是选择获得的最大的那个未分配内存块.<br>这种策略在每次分配后总是持有最大的内存块, 从而增加匹配的可能性. 与最佳匹配相比, 其他的请求可以使用剩余的空间.(最佳匹配的剩余内存往往无法利用)<br>同上例, 最坏匹配会从19k的那个内存块中分配, 并留下7k的内存留给将来使用.  </p>
</li>
<li><p>First fit:<br>There may be many holes in the memory, so the operating system, to reduce the amount of time it spends analyzing the available spaces, begins at the start of primary memory and allocates memory from the first hole it encounters large enough to satisfy the request. Using the same example as above, first fit will allocate 12KB of the 14KB block to the process.<br>通常内存中会存在很多空洞, 所以操作系统为了减少分析可用空间的性能(时间)消耗, 会从主要内存或者 第一个足够大并且满足求要的可分配内存的起始位置相应请求.<br>同上例中, 首先匹配会从14k的block中分配12k的请求.<br>First Fit的一个改良版本叫做Next Fit, 即在下次请求时会从上次中断的地方的开始搜索, 从而避免总是从起始的空闲内存开始查找. (Designated victim), First Fit的策略会倾向于总是把大块切的更零碎也因此带来更多的外部碎片问题, 也因为总是从空闲内存的头部开始切造成更多的内部碎片,  而Next Fit的做法会避免(改良)这些问题, 并且速度比Firt 以及 Best更快.  </p>
</li>
</ul>
<h4><span id="tlsf-a-new-dynamic-memory-allocator-for-real-time-systems">TLSF: a New Dynamic Memory Allocator for Real-Time Systems</span></h4><p>通过一组链表来管理不同大小内存块的内存分配算法。<br>适用环境和要求:<br>内存分配/释放的执行时间可预期，可接受的。由于RTOS对指令的执行时间有严格要求，所以常常采用静态内存分配的方法，以获得一个可以预期的执行时间。<br>内存分配算法的碎片化程度要低，这是由于RTOS往往长时间执行，碎片化程度高会导致内存分配失败。<br>实时系统动态内存算法<br>可信的执行环境，Trusted Environment，应用不会故意破坏数据或者窃取数据。<br>有限的物理内存。<br>没有物理MMU来支持虚拟内存。</p>
<p>核心概念: Two Level<br>基本的Segregated Fit算法是使用一组链表，每个链表只包含特定长度范围来的空闲块的方式来管理空闲块的，这样链表数组的长度可能会很大。如下图，TLSF为了简化查找定位过程，使用了两层链表。第一层，将空闲内存块的大小根据2的幂进行分类，如（16、32、64…）。第二层链表在第一层的基础上，按照一定的间隔，线性分段。比如2的6次方这一段，分为4个小区间【64,80），【80,96），【96,112），【112，128）.每一级的链表都有一个bitmap用于标记对应的链表中是否有内存块。比如第一级别bitmap的后4bit位0100，即2的6次方这个区间有空闲块。对应的第二级链表的bitmap位0010及【80,96）这个区间有空闲块，即下面的89 Byte。</p>
<p>策略:<br>Immediate coalescing，立即合并，当内存块被释放后，立即与相邻的空闲内存块合并，以获得一个更大的空闲块，插入到链表的相应位置。这样可以减少碎片化。<br>Splitting threshold，分割阈值，最小可分配的内存块大小为16字节，应用一般不会分配一些基本的数据结构，如int、char等。限定最小可分配大小为16字节，这样可以在空闲的内存块中存储一些管理信息。<br>Good-fit strategy，TLSF会尽可能的返回一个最小的、能够满足需求的内存块。<br>Same strategy for all block sizes，对于不同大小的内存请求，TLSF只有一个分配策略，实现相对简单，执行时间可以预期。相应的dlmalloc根据所请求的内存大小不同，有多达4种内存分配策略。<br>Memory is not cleaned-up，分配个应用的内存没有被请0.</p>
<p>特点:<br>可以预期的分配执行时间，无论对于多达的内存分配请求，TLSF可以在限定的时间内完成分配。<br>碎片化程度低。</p>
<h4><span id="mimalloc">mimalloc:</span></h4><h4><span id="多线程">多线程</span></h4><ul>
<li>局部化, 本地缓存/链表  </li>
<li>注意false shared  </li>
<li>跨线程队列 最大本地缓存 </li>
</ul>
<h4><span id="内存安全">内存安全</span></h4><p>管理数据和被管理内存分离<br>buddy system<br>pages 管理  </p>
<p>可信的执行环境Trusted Environment，应用不会故意破坏数据或者窃取数据<br>有限的物理内存<br>有限的物理地址<br>没有物理MMU来支持虚拟内存</p>
<h4><span id="开源内存分配器">开源内存分配器</span></h4><ul>
<li>dlmalloc </li>
<li>tcmalloc  </li>
<li>jemalloc  </li>
<li>Hoard</li>
<li>minimalloc</li>
<li>TLSF: <a href="https://github.com/OlegHahm/tlsf" target="_blank" rel="noopener">https://github.com/OlegHahm/tlsf</a>    </li>
</ul>
<h4><span id="援引">援引</span></h4><p><a href="https://github.com/everschen/tools/blob/master/DOC/Jemalloc.pdf" target="_blank" rel="noopener">jemalloc深入分析 PDF</a><br><a href="http://applicative.acm.org/2015/applicative.acm.org/speaker-JasonEvans.html" target="_blank" rel="noopener">jemalloc 2015演讲视频 tick tock, malloc needs a clock 背景和初始设计思想介绍</a><br><a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919" target="_blank" rel="noopener">jemalloc facebook工程贴</a><br><a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf" target="_blank" rel="noopener">BSDcan paper 2006</a><br><a href="https://dl.acm.org/doi/abs/10.1145/3329785.3329918" target="_blank" rel="noopener">On the Impact of Memory Allocationon High-Performance Query Processing</a><br><a href="https://www.jamesgolick.com/2013/5/19/how-tcmalloc-works.html" target="_blank" rel="noopener">How tcmalloc Works</a><br><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/out-of-memory-handling" target="_blank" rel="noopener">Chromimum Project: Out of memory handling</a><br><a href="https://rd.springer.com/content/pdf/10.1007%2F978-1-4842-4398-5_7.pdf" target="_blank" rel="noopener">Scalable Memory Allocation TBB</a><br><a href="https://cloud.tencent.com/developer/article/1173720" target="_blank" rel="noopener">ptmalloc,tcmalloc和jemalloc内存分配策略研究</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/05/09/2020-06-15-shadowsock-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/2020-06-15-shadowsock-proxy/" itemprop="url">shadowsocks代理远端和本地配置以及VPS上的bbr开启等</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="shadowsocks服务器配置"><a href="#shadowsocks服务器配置" class="headerlink" title="shadowsocks服务器配置"></a>shadowsocks服务器配置</h2><ul>
<li><p>安装shadowsocks  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shadowsocks</span><br></pre></td></tr></table></figure></li>
<li><p>配置shadowsocks<br>配置路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;shadowsocks&#x2F;config.json</span><br></pre></td></tr></table></figure></li>
<li><p>配置内容(参考):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:[&quot;::1&quot;, &quot;0.0.0.0&quot;],</span><br><span class="line">  &quot;mode&quot;:&quot;tcp_and_udp&quot;,</span><br><span class="line">  &quot;server_port&quot;:8080,</span><br><span class="line">  &quot;password&quot;:&quot;****&quot;,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/05/09/2020-06-15-shadowsock-proxy/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zsummer.github.io/2020/02/07/2020-02-03-shared-memory-resume-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏天">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="关于夏天的一切">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/2020-02-03-shared-memory-resume-overview/" itemprop="url">基于共享内存的对象池管理方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T00:00:00+08:00">
                2020-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="1-目录"><a href="#1-目录" class="headerlink" title="..1. 目录"></a>..1. 目录</h3><h3 id="通用的对象池方案"><a href="#通用的对象池方案" class="headerlink" title="通用的对象池方案"></a>通用的对象池方案</h3><p>该方案本质上一个简单分离存储的内存分配方案:<br>分配器维护多个空闲链表, 每个空闲链表包含大小相等的空闲块 每个块的大小为这个大小类中最大元素的大小, 不分割不合并.    </p>
<p><img src="/images/objpools.png" alt="buddy_system">  </p>
<h4 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象池管理器</span><br><span class="line">  [对象A条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象B条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象C条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数   </span><br><span class="line">  [对象D条目IDX]: 对象是否包含虚函数(是否需要重建虚函数表):  对象类型(对应条目IDX): 对象大小: 对象个数: 该条目总长: 条目对应内存地址:  条目对应对象起始地址: 空闲对象下标ID : 已分配计数</span><br></pre></td></tr></table></figure>

<p>单个条目指向的起始地址结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag|flag|flag : ...  FENCE SIZE: NODE SIZE :   FENCE SIZE: NODE SIZE :   ...</span><br></pre></td></tr></table></figure>
<p>条目指向的地址会首先保存flag标志标明该对象是否在使用中, 用于请求和释放时候的判定标志<br>NODE SIZE会进行8字节对齐, FENCE SIZE也选择8字节 这样整个对象池的地址都是保证8字节对齐的<br>FENCE写入特殊固定的魔法数值 用于溢出检测<br>分配出去的对象 NODE SIZE的起始地址即为对象的地址<br>空闲的对象, 其NODE SIZE的第一个U32保存的是下一个空闲内存 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: NODE SIZE: 对应下面结构</span><br><span class="line">: FREE IDX, NODE SIZE- FENCE SIZE:</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/07/2020-02-03-shared-memory-resume-overview/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="夏天" />
          <p class="site-author-name" itemprop="name">夏天</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">夏天</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
